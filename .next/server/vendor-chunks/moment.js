/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/moment";
exports.ids = ["vendor-chunks/moment"];
exports.modules = {

/***/ "(rsc)/./node_modules/moment/moment.js":
/*!***************************************!*\
  !*** ./node_modules/moment/moment.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\n//! moment.js\n//! version : 2.29.4\n//! authors : Tim Wood, Iskren Chernev, Moment.js contributors\n//! license : MIT\n//! momentjs.com\n;\n(function(global, factory) {\n     true ? module.exports = factory() : 0;\n})(this, function() {\n    \"use strict\";\n    var hookCallback;\n    function hooks() {\n        return hookCallback.apply(null, arguments);\n    }\n    // This is done to register the method called with moment()\n    // without creating circular dependencies.\n    function setHookCallback(callback) {\n        hookCallback = callback;\n    }\n    function isArray(input) {\n        return input instanceof Array || Object.prototype.toString.call(input) === \"[object Array]\";\n    }\n    function isObject(input) {\n        // IE8 will treat undefined and null as object if it wasn't for\n        // input != null\n        return input != null && Object.prototype.toString.call(input) === \"[object Object]\";\n    }\n    function hasOwnProp(a, b) {\n        return Object.prototype.hasOwnProperty.call(a, b);\n    }\n    function isObjectEmpty(obj) {\n        if (Object.getOwnPropertyNames) {\n            return Object.getOwnPropertyNames(obj).length === 0;\n        } else {\n            var k;\n            for(k in obj){\n                if (hasOwnProp(obj, k)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    function isUndefined(input) {\n        return input === void 0;\n    }\n    function isNumber(input) {\n        return typeof input === \"number\" || Object.prototype.toString.call(input) === \"[object Number]\";\n    }\n    function isDate(input) {\n        return input instanceof Date || Object.prototype.toString.call(input) === \"[object Date]\";\n    }\n    function map(arr, fn) {\n        var res = [], i, arrLen = arr.length;\n        for(i = 0; i < arrLen; ++i){\n            res.push(fn(arr[i], i));\n        }\n        return res;\n    }\n    function extend(a, b) {\n        for(var i in b){\n            if (hasOwnProp(b, i)) {\n                a[i] = b[i];\n            }\n        }\n        if (hasOwnProp(b, \"toString\")) {\n            a.toString = b.toString;\n        }\n        if (hasOwnProp(b, \"valueOf\")) {\n            a.valueOf = b.valueOf;\n        }\n        return a;\n    }\n    function createUTC(input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, true).utc();\n    }\n    function defaultParsingFlags() {\n        // We need to deep clone this object.\n        return {\n            empty: false,\n            unusedTokens: [],\n            unusedInput: [],\n            overflow: -2,\n            charsLeftOver: 0,\n            nullInput: false,\n            invalidEra: null,\n            invalidMonth: null,\n            invalidFormat: false,\n            userInvalidated: false,\n            iso: false,\n            parsedDateParts: [],\n            era: null,\n            meridiem: null,\n            rfc2822: false,\n            weekdayMismatch: false\n        };\n    }\n    function getParsingFlags(m) {\n        if (m._pf == null) {\n            m._pf = defaultParsingFlags();\n        }\n        return m._pf;\n    }\n    var some;\n    if (Array.prototype.some) {\n        some = Array.prototype.some;\n    } else {\n        some = function(fun) {\n            var t = Object(this), len = t.length >>> 0, i;\n            for(i = 0; i < len; i++){\n                if (i in t && fun.call(this, t[i], i, t)) {\n                    return true;\n                }\n            }\n            return false;\n        };\n    }\n    function isValid(m) {\n        if (m._isValid == null) {\n            var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {\n                return i != null;\n            }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);\n            if (m._strict) {\n                isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;\n            }\n            if (Object.isFrozen == null || !Object.isFrozen(m)) {\n                m._isValid = isNowValid;\n            } else {\n                return isNowValid;\n            }\n        }\n        return m._isValid;\n    }\n    function createInvalid(flags) {\n        var m = createUTC(NaN);\n        if (flags != null) {\n            extend(getParsingFlags(m), flags);\n        } else {\n            getParsingFlags(m).userInvalidated = true;\n        }\n        return m;\n    }\n    // Plugins that add properties should also add the key here (null value),\n    // so we can properly clone ourselves.\n    var momentProperties = hooks.momentProperties = [], updateInProgress = false;\n    function copyConfig(to, from) {\n        var i, prop, val, momentPropertiesLen = momentProperties.length;\n        if (!isUndefined(from._isAMomentObject)) {\n            to._isAMomentObject = from._isAMomentObject;\n        }\n        if (!isUndefined(from._i)) {\n            to._i = from._i;\n        }\n        if (!isUndefined(from._f)) {\n            to._f = from._f;\n        }\n        if (!isUndefined(from._l)) {\n            to._l = from._l;\n        }\n        if (!isUndefined(from._strict)) {\n            to._strict = from._strict;\n        }\n        if (!isUndefined(from._tzm)) {\n            to._tzm = from._tzm;\n        }\n        if (!isUndefined(from._isUTC)) {\n            to._isUTC = from._isUTC;\n        }\n        if (!isUndefined(from._offset)) {\n            to._offset = from._offset;\n        }\n        if (!isUndefined(from._pf)) {\n            to._pf = getParsingFlags(from);\n        }\n        if (!isUndefined(from._locale)) {\n            to._locale = from._locale;\n        }\n        if (momentPropertiesLen > 0) {\n            for(i = 0; i < momentPropertiesLen; i++){\n                prop = momentProperties[i];\n                val = from[prop];\n                if (!isUndefined(val)) {\n                    to[prop] = val;\n                }\n            }\n        }\n        return to;\n    }\n    // Moment prototype object\n    function Moment(config) {\n        copyConfig(this, config);\n        this._d = new Date(config._d != null ? config._d.getTime() : NaN);\n        if (!this.isValid()) {\n            this._d = new Date(NaN);\n        }\n        // Prevent infinite loop in case updateOffset creates new moment\n        // objects.\n        if (updateInProgress === false) {\n            updateInProgress = true;\n            hooks.updateOffset(this);\n            updateInProgress = false;\n        }\n    }\n    function isMoment(obj) {\n        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;\n    }\n    function warn(msg) {\n        if (hooks.suppressDeprecationWarnings === false && typeof console !== \"undefined\" && console.warn) {\n            console.warn(\"Deprecation warning: \" + msg);\n        }\n    }\n    function deprecate(msg, fn) {\n        var firstTime = true;\n        return extend(function() {\n            if (hooks.deprecationHandler != null) {\n                hooks.deprecationHandler(null, msg);\n            }\n            if (firstTime) {\n                var args = [], arg, i, key, argLen = arguments.length;\n                for(i = 0; i < argLen; i++){\n                    arg = \"\";\n                    if (typeof arguments[i] === \"object\") {\n                        arg += \"\\n[\" + i + \"] \";\n                        for(key in arguments[0]){\n                            if (hasOwnProp(arguments[0], key)) {\n                                arg += key + \": \" + arguments[0][key] + \", \";\n                            }\n                        }\n                        arg = arg.slice(0, -2); // Remove trailing comma and space\n                    } else {\n                        arg = arguments[i];\n                    }\n                    args.push(arg);\n                }\n                warn(msg + \"\\nArguments: \" + Array.prototype.slice.call(args).join(\"\") + \"\\n\" + new Error().stack);\n                firstTime = false;\n            }\n            return fn.apply(this, arguments);\n        }, fn);\n    }\n    var deprecations = {};\n    function deprecateSimple(name, msg) {\n        if (hooks.deprecationHandler != null) {\n            hooks.deprecationHandler(name, msg);\n        }\n        if (!deprecations[name]) {\n            warn(msg);\n            deprecations[name] = true;\n        }\n    }\n    hooks.suppressDeprecationWarnings = false;\n    hooks.deprecationHandler = null;\n    function isFunction(input) {\n        return typeof Function !== \"undefined\" && input instanceof Function || Object.prototype.toString.call(input) === \"[object Function]\";\n    }\n    function set(config) {\n        var prop, i;\n        for(i in config){\n            if (hasOwnProp(config, i)) {\n                prop = config[i];\n                if (isFunction(prop)) {\n                    this[i] = prop;\n                } else {\n                    this[\"_\" + i] = prop;\n                }\n            }\n        }\n        this._config = config;\n        // Lenient ordinal parsing accepts just a number in addition to\n        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + \"|\" + /\\d{1,2}/.source);\n    }\n    function mergeConfigs(parentConfig, childConfig) {\n        var res = extend({}, parentConfig), prop;\n        for(prop in childConfig){\n            if (hasOwnProp(childConfig, prop)) {\n                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {\n                    res[prop] = {};\n                    extend(res[prop], parentConfig[prop]);\n                    extend(res[prop], childConfig[prop]);\n                } else if (childConfig[prop] != null) {\n                    res[prop] = childConfig[prop];\n                } else {\n                    delete res[prop];\n                }\n            }\n        }\n        for(prop in parentConfig){\n            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {\n                // make sure changes to properties don't modify parent config\n                res[prop] = extend({}, res[prop]);\n            }\n        }\n        return res;\n    }\n    function Locale(config) {\n        if (config != null) {\n            this.set(config);\n        }\n    }\n    var keys;\n    if (Object.keys) {\n        keys = Object.keys;\n    } else {\n        keys = function(obj) {\n            var i, res = [];\n            for(i in obj){\n                if (hasOwnProp(obj, i)) {\n                    res.push(i);\n                }\n            }\n            return res;\n        };\n    }\n    var defaultCalendar = {\n        sameDay: \"[Today at] LT\",\n        nextDay: \"[Tomorrow at] LT\",\n        nextWeek: \"dddd [at] LT\",\n        lastDay: \"[Yesterday at] LT\",\n        lastWeek: \"[Last] dddd [at] LT\",\n        sameElse: \"L\"\n    };\n    function calendar(key, mom, now) {\n        var output = this._calendar[key] || this._calendar[\"sameElse\"];\n        return isFunction(output) ? output.call(mom, now) : output;\n    }\n    function zeroFill(number, targetLength, forceSign) {\n        var absNumber = \"\" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;\n        return (sign ? forceSign ? \"+\" : \"\" : \"-\") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;\n    }\n    var formattingTokens = /(\\[[^\\[]*\\])|(\\\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\\[[^\\[]*\\])|(\\\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};\n    // token:    'M'\n    // padded:   ['MM', 2]\n    // ordinal:  'Mo'\n    // callback: function () { this.month() + 1 }\n    function addFormatToken(token, padded, ordinal, callback) {\n        var func = callback;\n        if (typeof callback === \"string\") {\n            func = function() {\n                return this[callback]();\n            };\n        }\n        if (token) {\n            formatTokenFunctions[token] = func;\n        }\n        if (padded) {\n            formatTokenFunctions[padded[0]] = function() {\n                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);\n            };\n        }\n        if (ordinal) {\n            formatTokenFunctions[ordinal] = function() {\n                return this.localeData().ordinal(func.apply(this, arguments), token);\n            };\n        }\n    }\n    function removeFormattingTokens(input) {\n        if (input.match(/\\[[\\s\\S]/)) {\n            return input.replace(/^\\[|\\]$/g, \"\");\n        }\n        return input.replace(/\\\\/g, \"\");\n    }\n    function makeFormatFunction(format) {\n        var array = format.match(formattingTokens), i, length;\n        for(i = 0, length = array.length; i < length; i++){\n            if (formatTokenFunctions[array[i]]) {\n                array[i] = formatTokenFunctions[array[i]];\n            } else {\n                array[i] = removeFormattingTokens(array[i]);\n            }\n        }\n        return function(mom) {\n            var output = \"\", i;\n            for(i = 0; i < length; i++){\n                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];\n            }\n            return output;\n        };\n    }\n    // format date using native date object\n    function formatMoment(m, format) {\n        if (!m.isValid()) {\n            return m.localeData().invalidDate();\n        }\n        format = expandFormat(format, m.localeData());\n        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);\n        return formatFunctions[format](m);\n    }\n    function expandFormat(format, locale) {\n        var i = 5;\n        function replaceLongDateFormatTokens(input) {\n            return locale.longDateFormat(input) || input;\n        }\n        localFormattingTokens.lastIndex = 0;\n        while(i >= 0 && localFormattingTokens.test(format)){\n            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);\n            localFormattingTokens.lastIndex = 0;\n            i -= 1;\n        }\n        return format;\n    }\n    var defaultLongDateFormat = {\n        LTS: \"h:mm:ss A\",\n        LT: \"h:mm A\",\n        L: \"MM/DD/YYYY\",\n        LL: \"MMMM D, YYYY\",\n        LLL: \"MMMM D, YYYY h:mm A\",\n        LLLL: \"dddd, MMMM D, YYYY h:mm A\"\n    };\n    function longDateFormat(key) {\n        var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];\n        if (format || !formatUpper) {\n            return format;\n        }\n        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {\n            if (tok === \"MMMM\" || tok === \"MM\" || tok === \"DD\" || tok === \"dddd\") {\n                return tok.slice(1);\n            }\n            return tok;\n        }).join(\"\");\n        return this._longDateFormat[key];\n    }\n    var defaultInvalidDate = \"Invalid date\";\n    function invalidDate() {\n        return this._invalidDate;\n    }\n    var defaultOrdinal = \"%d\", defaultDayOfMonthOrdinalParse = /\\d{1,2}/;\n    function ordinal(number) {\n        return this._ordinal.replace(\"%d\", number);\n    }\n    var defaultRelativeTime = {\n        future: \"in %s\",\n        past: \"%s ago\",\n        s: \"a few seconds\",\n        ss: \"%d seconds\",\n        m: \"a minute\",\n        mm: \"%d minutes\",\n        h: \"an hour\",\n        hh: \"%d hours\",\n        d: \"a day\",\n        dd: \"%d days\",\n        w: \"a week\",\n        ww: \"%d weeks\",\n        M: \"a month\",\n        MM: \"%d months\",\n        y: \"a year\",\n        yy: \"%d years\"\n    };\n    function relativeTime(number, withoutSuffix, string, isFuture) {\n        var output = this._relativeTime[string];\n        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);\n    }\n    function pastFuture(diff, output) {\n        var format = this._relativeTime[diff > 0 ? \"future\" : \"past\"];\n        return isFunction(format) ? format(output) : format.replace(/%s/i, output);\n    }\n    var aliases = {};\n    function addUnitAlias(unit, shorthand) {\n        var lowerCase = unit.toLowerCase();\n        aliases[lowerCase] = aliases[lowerCase + \"s\"] = aliases[shorthand] = unit;\n    }\n    function normalizeUnits(units) {\n        return typeof units === \"string\" ? aliases[units] || aliases[units.toLowerCase()] : undefined;\n    }\n    function normalizeObjectUnits(inputObject) {\n        var normalizedInput = {}, normalizedProp, prop;\n        for(prop in inputObject){\n            if (hasOwnProp(inputObject, prop)) {\n                normalizedProp = normalizeUnits(prop);\n                if (normalizedProp) {\n                    normalizedInput[normalizedProp] = inputObject[prop];\n                }\n            }\n        }\n        return normalizedInput;\n    }\n    var priorities = {};\n    function addUnitPriority(unit, priority) {\n        priorities[unit] = priority;\n    }\n    function getPrioritizedUnits(unitsObj) {\n        var units = [], u;\n        for(u in unitsObj){\n            if (hasOwnProp(unitsObj, u)) {\n                units.push({\n                    unit: u,\n                    priority: priorities[u]\n                });\n            }\n        }\n        units.sort(function(a, b) {\n            return a.priority - b.priority;\n        });\n        return units;\n    }\n    function isLeapYear(year) {\n        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n    }\n    function absFloor(number) {\n        if (number < 0) {\n            // -0 -> 0\n            return Math.ceil(number) || 0;\n        } else {\n            return Math.floor(number);\n        }\n    }\n    function toInt(argumentForCoercion) {\n        var coercedNumber = +argumentForCoercion, value = 0;\n        if (coercedNumber !== 0 && isFinite(coercedNumber)) {\n            value = absFloor(coercedNumber);\n        }\n        return value;\n    }\n    function makeGetSet(unit, keepTime) {\n        return function(value) {\n            if (value != null) {\n                set$1(this, unit, value);\n                hooks.updateOffset(this, keepTime);\n                return this;\n            } else {\n                return get(this, unit);\n            }\n        };\n    }\n    function get(mom, unit) {\n        return mom.isValid() ? mom._d[\"get\" + (mom._isUTC ? \"UTC\" : \"\") + unit]() : NaN;\n    }\n    function set$1(mom, unit, value) {\n        if (mom.isValid() && !isNaN(value)) {\n            if (unit === \"FullYear\" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {\n                value = toInt(value);\n                mom._d[\"set\" + (mom._isUTC ? \"UTC\" : \"\") + unit](value, mom.month(), daysInMonth(value, mom.month()));\n            } else {\n                mom._d[\"set\" + (mom._isUTC ? \"UTC\" : \"\") + unit](value);\n            }\n        }\n    }\n    // MOMENTS\n    function stringGet(units) {\n        units = normalizeUnits(units);\n        if (isFunction(this[units])) {\n            return this[units]();\n        }\n        return this;\n    }\n    function stringSet(units, value) {\n        if (typeof units === \"object\") {\n            units = normalizeObjectUnits(units);\n            var prioritized = getPrioritizedUnits(units), i, prioritizedLen = prioritized.length;\n            for(i = 0; i < prioritizedLen; i++){\n                this[prioritized[i].unit](units[prioritized[i].unit]);\n            }\n        } else {\n            units = normalizeUnits(units);\n            if (isFunction(this[units])) {\n                return this[units](value);\n            }\n        }\n        return this;\n    }\n    var match1 = /\\d/, match2 = /\\d\\d/, match3 = /\\d{3}/, match4 = /\\d{4}/, match6 = /[+-]?\\d{6}/, match1to2 = /\\d\\d?/, match3to4 = /\\d\\d\\d\\d?/, match5to6 = /\\d\\d\\d\\d\\d\\d?/, match1to3 = /\\d{1,3}/, match1to4 = /\\d{1,4}/, match1to6 = /[+-]?\\d{1,6}/, matchUnsigned = /\\d+/, matchSigned = /[+-]?\\d+/, matchOffset = /Z|[+-]\\d\\d:?\\d\\d/gi, matchShortOffset = /Z|[+-]\\d\\d(?::?\\d\\d)?/gi, matchTimestamp = /[+-]?\\d+(\\.\\d{1,3})?/, // any word (or two) characters or numbers including two/three word month in arabic.\n    // includes scottish gaelic two word and hyphenated months\n    matchWord = /[0-9]{0,256}['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFF07\\uFF10-\\uFFEF]{1,256}|[\\u0600-\\u06FF\\/]{1,256}(\\s*?[\\u0600-\\u06FF]{1,256}){1,2}/i, regexes;\n    regexes = {};\n    function addRegexToken(token, regex, strictRegex) {\n        regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {\n            return isStrict && strictRegex ? strictRegex : regex;\n        };\n    }\n    function getParseRegexForToken(token, config) {\n        if (!hasOwnProp(regexes, token)) {\n            return new RegExp(unescapeFormat(token));\n        }\n        return regexes[token](config._strict, config._locale);\n    }\n    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript\n    function unescapeFormat(s) {\n        return regexEscape(s.replace(\"\\\\\", \"\").replace(/\\\\(\\[)|\\\\(\\])|\\[([^\\]\\[]*)\\]|\\\\(.)/g, function(matched, p1, p2, p3, p4) {\n            return p1 || p2 || p3 || p4;\n        }));\n    }\n    function regexEscape(s) {\n        return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n    }\n    var tokens = {};\n    function addParseToken(token, callback) {\n        var i, func = callback, tokenLen;\n        if (typeof token === \"string\") {\n            token = [\n                token\n            ];\n        }\n        if (isNumber(callback)) {\n            func = function(input, array) {\n                array[callback] = toInt(input);\n            };\n        }\n        tokenLen = token.length;\n        for(i = 0; i < tokenLen; i++){\n            tokens[token[i]] = func;\n        }\n    }\n    function addWeekParseToken(token, callback) {\n        addParseToken(token, function(input, array, config, token) {\n            config._w = config._w || {};\n            callback(input, config._w, config, token);\n        });\n    }\n    function addTimeToArrayFromToken(token, input, config) {\n        if (input != null && hasOwnProp(tokens, token)) {\n            tokens[token](input, config._a, config, token);\n        }\n    }\n    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;\n    function mod(n, x) {\n        return (n % x + x) % x;\n    }\n    var indexOf;\n    if (Array.prototype.indexOf) {\n        indexOf = Array.prototype.indexOf;\n    } else {\n        indexOf = function(o) {\n            // I know\n            var i;\n            for(i = 0; i < this.length; ++i){\n                if (this[i] === o) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n    }\n    function daysInMonth(year, month) {\n        if (isNaN(year) || isNaN(month)) {\n            return NaN;\n        }\n        var modMonth = mod(month, 12);\n        year += (month - modMonth) / 12;\n        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;\n    }\n    // FORMATTING\n    addFormatToken(\"M\", [\n        \"MM\",\n        2\n    ], \"Mo\", function() {\n        return this.month() + 1;\n    });\n    addFormatToken(\"MMM\", 0, 0, function(format) {\n        return this.localeData().monthsShort(this, format);\n    });\n    addFormatToken(\"MMMM\", 0, 0, function(format) {\n        return this.localeData().months(this, format);\n    });\n    // ALIASES\n    addUnitAlias(\"month\", \"M\");\n    // PRIORITY\n    addUnitPriority(\"month\", 8);\n    // PARSING\n    addRegexToken(\"M\", match1to2);\n    addRegexToken(\"MM\", match1to2, match2);\n    addRegexToken(\"MMM\", function(isStrict, locale) {\n        return locale.monthsShortRegex(isStrict);\n    });\n    addRegexToken(\"MMMM\", function(isStrict, locale) {\n        return locale.monthsRegex(isStrict);\n    });\n    addParseToken([\n        \"M\",\n        \"MM\"\n    ], function(input, array) {\n        array[MONTH] = toInt(input) - 1;\n    });\n    addParseToken([\n        \"MMM\",\n        \"MMMM\"\n    ], function(input, array, config, token) {\n        var month = config._locale.monthsParse(input, token, config._strict);\n        // if we didn't find a month name, mark the date as invalid.\n        if (month != null) {\n            array[MONTH] = month;\n        } else {\n            getParsingFlags(config).invalidMonth = input;\n        }\n    });\n    // LOCALES\n    var defaultLocaleMonths = \"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"), defaultLocaleMonthsShort = \"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec\".split(\"_\"), MONTHS_IN_FORMAT = /D[oD]?(\\[[^\\[\\]]*\\]|\\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;\n    function localeMonths(m, format) {\n        if (!m) {\n            return isArray(this._months) ? this._months : this._months[\"standalone\"];\n        }\n        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? \"format\" : \"standalone\"][m.month()];\n    }\n    function localeMonthsShort(m, format) {\n        if (!m) {\n            return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort[\"standalone\"];\n        }\n        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? \"format\" : \"standalone\"][m.month()];\n    }\n    function handleStrictParse(monthName, format, strict) {\n        var i, ii, mom, llc = monthName.toLocaleLowerCase();\n        if (!this._monthsParse) {\n            // this is not used\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n            for(i = 0; i < 12; ++i){\n                mom = createUTC([\n                    2000,\n                    i\n                ]);\n                this._shortMonthsParse[i] = this.monthsShort(mom, \"\").toLocaleLowerCase();\n                this._longMonthsParse[i] = this.months(mom, \"\").toLocaleLowerCase();\n            }\n        }\n        if (strict) {\n            if (format === \"MMM\") {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === \"MMM\") {\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._longMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._longMonthsParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortMonthsParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n    function localeMonthsParse(monthName, format, strict) {\n        var i, mom, regex;\n        if (this._monthsParseExact) {\n            return handleStrictParse.call(this, monthName, format, strict);\n        }\n        if (!this._monthsParse) {\n            this._monthsParse = [];\n            this._longMonthsParse = [];\n            this._shortMonthsParse = [];\n        }\n        // TODO: add sorting\n        // Sorting makes sure if one month (or abbr) is a prefix of another\n        // see sorting in computeMonthsParse\n        for(i = 0; i < 12; i++){\n            // make the regex if we don't have it already\n            mom = createUTC([\n                2000,\n                i\n            ]);\n            if (strict && !this._longMonthsParse[i]) {\n                this._longMonthsParse[i] = new RegExp(\"^\" + this.months(mom, \"\").replace(\".\", \"\") + \"$\", \"i\");\n                this._shortMonthsParse[i] = new RegExp(\"^\" + this.monthsShort(mom, \"\").replace(\".\", \"\") + \"$\", \"i\");\n            }\n            if (!strict && !this._monthsParse[i]) {\n                regex = \"^\" + this.months(mom, \"\") + \"|^\" + this.monthsShort(mom, \"\");\n                this._monthsParse[i] = new RegExp(regex.replace(\".\", \"\"), \"i\");\n            }\n            // test the regex\n            if (strict && format === \"MMMM\" && this._longMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (strict && format === \"MMM\" && this._shortMonthsParse[i].test(monthName)) {\n                return i;\n            } else if (!strict && this._monthsParse[i].test(monthName)) {\n                return i;\n            }\n        }\n    }\n    // MOMENTS\n    function setMonth(mom, value) {\n        var dayOfMonth;\n        if (!mom.isValid()) {\n            // No op\n            return mom;\n        }\n        if (typeof value === \"string\") {\n            if (/^\\d+$/.test(value)) {\n                value = toInt(value);\n            } else {\n                value = mom.localeData().monthsParse(value);\n                // TODO: Another silent failure?\n                if (!isNumber(value)) {\n                    return mom;\n                }\n            }\n        }\n        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));\n        mom._d[\"set\" + (mom._isUTC ? \"UTC\" : \"\") + \"Month\"](value, dayOfMonth);\n        return mom;\n    }\n    function getSetMonth(value) {\n        if (value != null) {\n            setMonth(this, value);\n            hooks.updateOffset(this, true);\n            return this;\n        } else {\n            return get(this, \"Month\");\n        }\n    }\n    function getDaysInMonth() {\n        return daysInMonth(this.year(), this.month());\n    }\n    function monthsShortRegex(isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, \"_monthsRegex\")) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsShortStrictRegex;\n            } else {\n                return this._monthsShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, \"_monthsShortRegex\")) {\n                this._monthsShortRegex = defaultMonthsShortRegex;\n            }\n            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;\n        }\n    }\n    function monthsRegex(isStrict) {\n        if (this._monthsParseExact) {\n            if (!hasOwnProp(this, \"_monthsRegex\")) {\n                computeMonthsParse.call(this);\n            }\n            if (isStrict) {\n                return this._monthsStrictRegex;\n            } else {\n                return this._monthsRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, \"_monthsRegex\")) {\n                this._monthsRegex = defaultMonthsRegex;\n            }\n            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;\n        }\n    }\n    function computeMonthsParse() {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;\n        for(i = 0; i < 12; i++){\n            // make the regex if we don't have it already\n            mom = createUTC([\n                2000,\n                i\n            ]);\n            shortPieces.push(this.monthsShort(mom, \"\"));\n            longPieces.push(this.months(mom, \"\"));\n            mixedPieces.push(this.months(mom, \"\"));\n            mixedPieces.push(this.monthsShort(mom, \"\"));\n        }\n        // Sorting makes sure if one month (or abbr) is a prefix of another it\n        // will match the longer piece.\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        for(i = 0; i < 12; i++){\n            shortPieces[i] = regexEscape(shortPieces[i]);\n            longPieces[i] = regexEscape(longPieces[i]);\n        }\n        for(i = 0; i < 24; i++){\n            mixedPieces[i] = regexEscape(mixedPieces[i]);\n        }\n        this._monthsRegex = new RegExp(\"^(\" + mixedPieces.join(\"|\") + \")\", \"i\");\n        this._monthsShortRegex = this._monthsRegex;\n        this._monthsStrictRegex = new RegExp(\"^(\" + longPieces.join(\"|\") + \")\", \"i\");\n        this._monthsShortStrictRegex = new RegExp(\"^(\" + shortPieces.join(\"|\") + \")\", \"i\");\n    }\n    // FORMATTING\n    addFormatToken(\"Y\", 0, 0, function() {\n        var y = this.year();\n        return y <= 9999 ? zeroFill(y, 4) : \"+\" + y;\n    });\n    addFormatToken(0, [\n        \"YY\",\n        2\n    ], 0, function() {\n        return this.year() % 100;\n    });\n    addFormatToken(0, [\n        \"YYYY\",\n        4\n    ], 0, \"year\");\n    addFormatToken(0, [\n        \"YYYYY\",\n        5\n    ], 0, \"year\");\n    addFormatToken(0, [\n        \"YYYYYY\",\n        6,\n        true\n    ], 0, \"year\");\n    // ALIASES\n    addUnitAlias(\"year\", \"y\");\n    // PRIORITIES\n    addUnitPriority(\"year\", 1);\n    // PARSING\n    addRegexToken(\"Y\", matchSigned);\n    addRegexToken(\"YY\", match1to2, match2);\n    addRegexToken(\"YYYY\", match1to4, match4);\n    addRegexToken(\"YYYYY\", match1to6, match6);\n    addRegexToken(\"YYYYYY\", match1to6, match6);\n    addParseToken([\n        \"YYYYY\",\n        \"YYYYYY\"\n    ], YEAR);\n    addParseToken(\"YYYY\", function(input, array) {\n        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);\n    });\n    addParseToken(\"YY\", function(input, array) {\n        array[YEAR] = hooks.parseTwoDigitYear(input);\n    });\n    addParseToken(\"Y\", function(input, array) {\n        array[YEAR] = parseInt(input, 10);\n    });\n    // HELPERS\n    function daysInYear(year) {\n        return isLeapYear(year) ? 366 : 365;\n    }\n    // HOOKS\n    hooks.parseTwoDigitYear = function(input) {\n        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);\n    };\n    // MOMENTS\n    var getSetYear = makeGetSet(\"FullYear\", true);\n    function getIsLeapYear() {\n        return isLeapYear(this.year());\n    }\n    function createDate(y, m, d, h, M, s, ms) {\n        // can't just apply() to create a date:\n        // https://stackoverflow.com/q/181348\n        var date;\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            date = new Date(y + 400, m, d, h, M, s, ms);\n            if (isFinite(date.getFullYear())) {\n                date.setFullYear(y);\n            }\n        } else {\n            date = new Date(y, m, d, h, M, s, ms);\n        }\n        return date;\n    }\n    function createUTCDate(y) {\n        var date, args;\n        // the Date.UTC function remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            args = Array.prototype.slice.call(arguments);\n            // preserve leap years using a full 400 year cycle, then reset\n            args[0] = y + 400;\n            date = new Date(Date.UTC.apply(null, args));\n            if (isFinite(date.getUTCFullYear())) {\n                date.setUTCFullYear(y);\n            }\n        } else {\n            date = new Date(Date.UTC.apply(null, arguments));\n        }\n        return date;\n    }\n    // start-of-first-week - start-of-year\n    function firstWeekOffset(year, dow, doy) {\n        var fwd = 7 + dow - doy, // first-week day local weekday -- which local weekday is fwd\n        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;\n        return -fwdlw + fwd - 1;\n    }\n    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday\n    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {\n        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;\n        if (dayOfYear <= 0) {\n            resYear = year - 1;\n            resDayOfYear = daysInYear(resYear) + dayOfYear;\n        } else if (dayOfYear > daysInYear(year)) {\n            resYear = year + 1;\n            resDayOfYear = dayOfYear - daysInYear(year);\n        } else {\n            resYear = year;\n            resDayOfYear = dayOfYear;\n        }\n        return {\n            year: resYear,\n            dayOfYear: resDayOfYear\n        };\n    }\n    function weekOfYear(mom, dow, doy) {\n        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;\n        if (week < 1) {\n            resYear = mom.year() - 1;\n            resWeek = week + weeksInYear(resYear, dow, doy);\n        } else if (week > weeksInYear(mom.year(), dow, doy)) {\n            resWeek = week - weeksInYear(mom.year(), dow, doy);\n            resYear = mom.year() + 1;\n        } else {\n            resYear = mom.year();\n            resWeek = week;\n        }\n        return {\n            week: resWeek,\n            year: resYear\n        };\n    }\n    function weeksInYear(year, dow, doy) {\n        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);\n        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;\n    }\n    // FORMATTING\n    addFormatToken(\"w\", [\n        \"ww\",\n        2\n    ], \"wo\", \"week\");\n    addFormatToken(\"W\", [\n        \"WW\",\n        2\n    ], \"Wo\", \"isoWeek\");\n    // ALIASES\n    addUnitAlias(\"week\", \"w\");\n    addUnitAlias(\"isoWeek\", \"W\");\n    // PRIORITIES\n    addUnitPriority(\"week\", 5);\n    addUnitPriority(\"isoWeek\", 5);\n    // PARSING\n    addRegexToken(\"w\", match1to2);\n    addRegexToken(\"ww\", match1to2, match2);\n    addRegexToken(\"W\", match1to2);\n    addRegexToken(\"WW\", match1to2, match2);\n    addWeekParseToken([\n        \"w\",\n        \"ww\",\n        \"W\",\n        \"WW\"\n    ], function(input, week, config, token) {\n        week[token.substr(0, 1)] = toInt(input);\n    });\n    // HELPERS\n    // LOCALES\n    function localeWeek(mom) {\n        return weekOfYear(mom, this._week.dow, this._week.doy).week;\n    }\n    var defaultLocaleWeek = {\n        dow: 0,\n        doy: 6\n    };\n    function localeFirstDayOfWeek() {\n        return this._week.dow;\n    }\n    function localeFirstDayOfYear() {\n        return this._week.doy;\n    }\n    // MOMENTS\n    function getSetWeek(input) {\n        var week = this.localeData().week(this);\n        return input == null ? week : this.add((input - week) * 7, \"d\");\n    }\n    function getSetISOWeek(input) {\n        var week = weekOfYear(this, 1, 4).week;\n        return input == null ? week : this.add((input - week) * 7, \"d\");\n    }\n    // FORMATTING\n    addFormatToken(\"d\", 0, \"do\", \"day\");\n    addFormatToken(\"dd\", 0, 0, function(format) {\n        return this.localeData().weekdaysMin(this, format);\n    });\n    addFormatToken(\"ddd\", 0, 0, function(format) {\n        return this.localeData().weekdaysShort(this, format);\n    });\n    addFormatToken(\"dddd\", 0, 0, function(format) {\n        return this.localeData().weekdays(this, format);\n    });\n    addFormatToken(\"e\", 0, 0, \"weekday\");\n    addFormatToken(\"E\", 0, 0, \"isoWeekday\");\n    // ALIASES\n    addUnitAlias(\"day\", \"d\");\n    addUnitAlias(\"weekday\", \"e\");\n    addUnitAlias(\"isoWeekday\", \"E\");\n    // PRIORITY\n    addUnitPriority(\"day\", 11);\n    addUnitPriority(\"weekday\", 11);\n    addUnitPriority(\"isoWeekday\", 11);\n    // PARSING\n    addRegexToken(\"d\", match1to2);\n    addRegexToken(\"e\", match1to2);\n    addRegexToken(\"E\", match1to2);\n    addRegexToken(\"dd\", function(isStrict, locale) {\n        return locale.weekdaysMinRegex(isStrict);\n    });\n    addRegexToken(\"ddd\", function(isStrict, locale) {\n        return locale.weekdaysShortRegex(isStrict);\n    });\n    addRegexToken(\"dddd\", function(isStrict, locale) {\n        return locale.weekdaysRegex(isStrict);\n    });\n    addWeekParseToken([\n        \"dd\",\n        \"ddd\",\n        \"dddd\"\n    ], function(input, week, config, token) {\n        var weekday = config._locale.weekdaysParse(input, token, config._strict);\n        // if we didn't get a weekday name, mark the date as invalid\n        if (weekday != null) {\n            week.d = weekday;\n        } else {\n            getParsingFlags(config).invalidWeekday = input;\n        }\n    });\n    addWeekParseToken([\n        \"d\",\n        \"e\",\n        \"E\"\n    ], function(input, week, config, token) {\n        week[token] = toInt(input);\n    });\n    // HELPERS\n    function parseWeekday(input, locale) {\n        if (typeof input !== \"string\") {\n            return input;\n        }\n        if (!isNaN(input)) {\n            return parseInt(input, 10);\n        }\n        input = locale.weekdaysParse(input);\n        if (typeof input === \"number\") {\n            return input;\n        }\n        return null;\n    }\n    function parseIsoWeekday(input, locale) {\n        if (typeof input === \"string\") {\n            return locale.weekdaysParse(input) % 7 || 7;\n        }\n        return isNaN(input) ? null : input;\n    }\n    // LOCALES\n    function shiftWeekdays(ws, n) {\n        return ws.slice(n, 7).concat(ws.slice(0, n));\n    }\n    var defaultLocaleWeekdays = \"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"), defaultLocaleWeekdaysShort = \"Sun_Mon_Tue_Wed_Thu_Fri_Sat\".split(\"_\"), defaultLocaleWeekdaysMin = \"Su_Mo_Tu_We_Th_Fr_Sa\".split(\"_\"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;\n    function localeWeekdays(m, format) {\n        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? \"format\" : \"standalone\"];\n        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;\n    }\n    function localeWeekdaysShort(m) {\n        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;\n    }\n    function localeWeekdaysMin(m) {\n        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;\n    }\n    function handleStrictParse$1(weekdayName, format, strict) {\n        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._minWeekdaysParse = [];\n            for(i = 0; i < 7; ++i){\n                mom = createUTC([\n                    2000,\n                    1\n                ]).day(i);\n                this._minWeekdaysParse[i] = this.weekdaysMin(mom, \"\").toLocaleLowerCase();\n                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, \"\").toLocaleLowerCase();\n                this._weekdaysParse[i] = this.weekdays(mom, \"\").toLocaleLowerCase();\n            }\n        }\n        if (strict) {\n            if (format === \"dddd\") {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === \"ddd\") {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        } else {\n            if (format === \"dddd\") {\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else if (format === \"ddd\") {\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            } else {\n                ii = indexOf.call(this._minWeekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._weekdaysParse, llc);\n                if (ii !== -1) {\n                    return ii;\n                }\n                ii = indexOf.call(this._shortWeekdaysParse, llc);\n                return ii !== -1 ? ii : null;\n            }\n        }\n    }\n    function localeWeekdaysParse(weekdayName, format, strict) {\n        var i, mom, regex;\n        if (this._weekdaysParseExact) {\n            return handleStrictParse$1.call(this, weekdayName, format, strict);\n        }\n        if (!this._weekdaysParse) {\n            this._weekdaysParse = [];\n            this._minWeekdaysParse = [];\n            this._shortWeekdaysParse = [];\n            this._fullWeekdaysParse = [];\n        }\n        for(i = 0; i < 7; i++){\n            // make the regex if we don't have it already\n            mom = createUTC([\n                2000,\n                1\n            ]).day(i);\n            if (strict && !this._fullWeekdaysParse[i]) {\n                this._fullWeekdaysParse[i] = new RegExp(\"^\" + this.weekdays(mom, \"\").replace(\".\", \"\\\\.?\") + \"$\", \"i\");\n                this._shortWeekdaysParse[i] = new RegExp(\"^\" + this.weekdaysShort(mom, \"\").replace(\".\", \"\\\\.?\") + \"$\", \"i\");\n                this._minWeekdaysParse[i] = new RegExp(\"^\" + this.weekdaysMin(mom, \"\").replace(\".\", \"\\\\.?\") + \"$\", \"i\");\n            }\n            if (!this._weekdaysParse[i]) {\n                regex = \"^\" + this.weekdays(mom, \"\") + \"|^\" + this.weekdaysShort(mom, \"\") + \"|^\" + this.weekdaysMin(mom, \"\");\n                this._weekdaysParse[i] = new RegExp(regex.replace(\".\", \"\"), \"i\");\n            }\n            // test the regex\n            if (strict && format === \"dddd\" && this._fullWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === \"ddd\" && this._shortWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (strict && format === \"dd\" && this._minWeekdaysParse[i].test(weekdayName)) {\n                return i;\n            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {\n                return i;\n            }\n        }\n    }\n    // MOMENTS\n    function getSetDayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();\n        if (input != null) {\n            input = parseWeekday(input, this.localeData());\n            return this.add(input - day, \"d\");\n        } else {\n            return day;\n        }\n    }\n    function getSetLocaleDayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;\n        return input == null ? weekday : this.add(input - weekday, \"d\");\n    }\n    function getSetISODayOfWeek(input) {\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        // behaves the same as moment#day except\n        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)\n        // as a setter, sunday should belong to the previous week.\n        if (input != null) {\n            var weekday = parseIsoWeekday(input, this.localeData());\n            return this.day(this.day() % 7 ? weekday : weekday - 7);\n        } else {\n            return this.day() || 7;\n        }\n    }\n    function weekdaysRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, \"_weekdaysRegex\")) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysStrictRegex;\n            } else {\n                return this._weekdaysRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, \"_weekdaysRegex\")) {\n                this._weekdaysRegex = defaultWeekdaysRegex;\n            }\n            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;\n        }\n    }\n    function weekdaysShortRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, \"_weekdaysRegex\")) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysShortStrictRegex;\n            } else {\n                return this._weekdaysShortRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, \"_weekdaysShortRegex\")) {\n                this._weekdaysShortRegex = defaultWeekdaysShortRegex;\n            }\n            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;\n        }\n    }\n    function weekdaysMinRegex(isStrict) {\n        if (this._weekdaysParseExact) {\n            if (!hasOwnProp(this, \"_weekdaysRegex\")) {\n                computeWeekdaysParse.call(this);\n            }\n            if (isStrict) {\n                return this._weekdaysMinStrictRegex;\n            } else {\n                return this._weekdaysMinRegex;\n            }\n        } else {\n            if (!hasOwnProp(this, \"_weekdaysMinRegex\")) {\n                this._weekdaysMinRegex = defaultWeekdaysMinRegex;\n            }\n            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;\n        }\n    }\n    function computeWeekdaysParse() {\n        function cmpLenRev(a, b) {\n            return b.length - a.length;\n        }\n        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;\n        for(i = 0; i < 7; i++){\n            // make the regex if we don't have it already\n            mom = createUTC([\n                2000,\n                1\n            ]).day(i);\n            minp = regexEscape(this.weekdaysMin(mom, \"\"));\n            shortp = regexEscape(this.weekdaysShort(mom, \"\"));\n            longp = regexEscape(this.weekdays(mom, \"\"));\n            minPieces.push(minp);\n            shortPieces.push(shortp);\n            longPieces.push(longp);\n            mixedPieces.push(minp);\n            mixedPieces.push(shortp);\n            mixedPieces.push(longp);\n        }\n        // Sorting makes sure if one weekday (or abbr) is a prefix of another it\n        // will match the longer piece.\n        minPieces.sort(cmpLenRev);\n        shortPieces.sort(cmpLenRev);\n        longPieces.sort(cmpLenRev);\n        mixedPieces.sort(cmpLenRev);\n        this._weekdaysRegex = new RegExp(\"^(\" + mixedPieces.join(\"|\") + \")\", \"i\");\n        this._weekdaysShortRegex = this._weekdaysRegex;\n        this._weekdaysMinRegex = this._weekdaysRegex;\n        this._weekdaysStrictRegex = new RegExp(\"^(\" + longPieces.join(\"|\") + \")\", \"i\");\n        this._weekdaysShortStrictRegex = new RegExp(\"^(\" + shortPieces.join(\"|\") + \")\", \"i\");\n        this._weekdaysMinStrictRegex = new RegExp(\"^(\" + minPieces.join(\"|\") + \")\", \"i\");\n    }\n    // FORMATTING\n    function hFormat() {\n        return this.hours() % 12 || 12;\n    }\n    function kFormat() {\n        return this.hours() || 24;\n    }\n    addFormatToken(\"H\", [\n        \"HH\",\n        2\n    ], 0, \"hour\");\n    addFormatToken(\"h\", [\n        \"hh\",\n        2\n    ], 0, hFormat);\n    addFormatToken(\"k\", [\n        \"kk\",\n        2\n    ], 0, kFormat);\n    addFormatToken(\"hmm\", 0, 0, function() {\n        return \"\" + hFormat.apply(this) + zeroFill(this.minutes(), 2);\n    });\n    addFormatToken(\"hmmss\", 0, 0, function() {\n        return \"\" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);\n    });\n    addFormatToken(\"Hmm\", 0, 0, function() {\n        return \"\" + this.hours() + zeroFill(this.minutes(), 2);\n    });\n    addFormatToken(\"Hmmss\", 0, 0, function() {\n        return \"\" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);\n    });\n    function meridiem(token, lowercase) {\n        addFormatToken(token, 0, 0, function() {\n            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);\n        });\n    }\n    meridiem(\"a\", true);\n    meridiem(\"A\", false);\n    // ALIASES\n    addUnitAlias(\"hour\", \"h\");\n    // PRIORITY\n    addUnitPriority(\"hour\", 13);\n    // PARSING\n    function matchMeridiem(isStrict, locale) {\n        return locale._meridiemParse;\n    }\n    addRegexToken(\"a\", matchMeridiem);\n    addRegexToken(\"A\", matchMeridiem);\n    addRegexToken(\"H\", match1to2);\n    addRegexToken(\"h\", match1to2);\n    addRegexToken(\"k\", match1to2);\n    addRegexToken(\"HH\", match1to2, match2);\n    addRegexToken(\"hh\", match1to2, match2);\n    addRegexToken(\"kk\", match1to2, match2);\n    addRegexToken(\"hmm\", match3to4);\n    addRegexToken(\"hmmss\", match5to6);\n    addRegexToken(\"Hmm\", match3to4);\n    addRegexToken(\"Hmmss\", match5to6);\n    addParseToken([\n        \"H\",\n        \"HH\"\n    ], HOUR);\n    addParseToken([\n        \"k\",\n        \"kk\"\n    ], function(input, array, config) {\n        var kInput = toInt(input);\n        array[HOUR] = kInput === 24 ? 0 : kInput;\n    });\n    addParseToken([\n        \"a\",\n        \"A\"\n    ], function(input, array, config) {\n        config._isPm = config._locale.isPM(input);\n        config._meridiem = input;\n    });\n    addParseToken([\n        \"h\",\n        \"hh\"\n    ], function(input, array, config) {\n        array[HOUR] = toInt(input);\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken(\"hmm\", function(input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken(\"hmmss\", function(input, array, config) {\n        var pos1 = input.length - 4, pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n        getParsingFlags(config).bigHour = true;\n    });\n    addParseToken(\"Hmm\", function(input, array, config) {\n        var pos = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos));\n        array[MINUTE] = toInt(input.substr(pos));\n    });\n    addParseToken(\"Hmmss\", function(input, array, config) {\n        var pos1 = input.length - 4, pos2 = input.length - 2;\n        array[HOUR] = toInt(input.substr(0, pos1));\n        array[MINUTE] = toInt(input.substr(pos1, 2));\n        array[SECOND] = toInt(input.substr(pos2));\n    });\n    // LOCALES\n    function localeIsPM(input) {\n        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays\n        // Using charAt should be more compatible.\n        return (input + \"\").toLowerCase().charAt(0) === \"p\";\n    }\n    var defaultLocaleMeridiemParse = /[ap]\\.?m?\\.?/i, // Setting the hour should keep the time, because the user explicitly\n    // specified which hour they want. So trying to maintain the same hour (in\n    // a new timezone) makes sense. Adding/subtracting hours does not follow\n    // this rule.\n    getSetHour = makeGetSet(\"Hours\", true);\n    function localeMeridiem(hours, minutes, isLower) {\n        if (hours > 11) {\n            return isLower ? \"pm\" : \"PM\";\n        } else {\n            return isLower ? \"am\" : \"AM\";\n        }\n    }\n    var baseConfig = {\n        calendar: defaultCalendar,\n        longDateFormat: defaultLongDateFormat,\n        invalidDate: defaultInvalidDate,\n        ordinal: defaultOrdinal,\n        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,\n        relativeTime: defaultRelativeTime,\n        months: defaultLocaleMonths,\n        monthsShort: defaultLocaleMonthsShort,\n        week: defaultLocaleWeek,\n        weekdays: defaultLocaleWeekdays,\n        weekdaysMin: defaultLocaleWeekdaysMin,\n        weekdaysShort: defaultLocaleWeekdaysShort,\n        meridiemParse: defaultLocaleMeridiemParse\n    };\n    // internal storage for locale config files\n    var locales = {}, localeFamilies = {}, globalLocale;\n    function commonPrefix(arr1, arr2) {\n        var i, minl = Math.min(arr1.length, arr2.length);\n        for(i = 0; i < minl; i += 1){\n            if (arr1[i] !== arr2[i]) {\n                return i;\n            }\n        }\n        return minl;\n    }\n    function normalizeLocale(key) {\n        return key ? key.toLowerCase().replace(\"_\", \"-\") : key;\n    }\n    // pick the locale from the array\n    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each\n    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root\n    function chooseLocale(names) {\n        var i = 0, j, next, locale, split;\n        while(i < names.length){\n            split = normalizeLocale(names[i]).split(\"-\");\n            j = split.length;\n            next = normalizeLocale(names[i + 1]);\n            next = next ? next.split(\"-\") : null;\n            while(j > 0){\n                locale = loadLocale(split.slice(0, j).join(\"-\"));\n                if (locale) {\n                    return locale;\n                }\n                if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {\n                    break;\n                }\n                j--;\n            }\n            i++;\n        }\n        return globalLocale;\n    }\n    function isLocaleNameSane(name) {\n        // Prevent names that look like filesystem paths, i.e contain '/' or '\\'\n        return name.match(\"^[^/\\\\\\\\]*$\") != null;\n    }\n    function loadLocale(name) {\n        var oldLocale = null, aliasedRequire;\n        // TODO: Find a better way to register and load all the locales in Node\n        if (locales[name] === undefined && \"object\" !== \"undefined\" && module && module.exports && isLocaleNameSane(name)) {\n            try {\n                oldLocale = globalLocale._abbr;\n                aliasedRequire = undefined;\n                Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'undefined'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }());\n                getSetGlobalLocale(oldLocale);\n            } catch (e) {\n                // mark as not found to avoid repeating expensive file require call causing high CPU\n                // when trying to find en-US, en_US, en-us for every format call\n                locales[name] = null; // null means not found\n            }\n        }\n        return locales[name];\n    }\n    // This function will load locale and then set the global locale.  If\n    // no arguments are passed in, it will simply return the current global\n    // locale key.\n    function getSetGlobalLocale(key, values) {\n        var data;\n        if (key) {\n            if (isUndefined(values)) {\n                data = getLocale(key);\n            } else {\n                data = defineLocale(key, values);\n            }\n            if (data) {\n                // moment.duration._locale = moment._locale = data;\n                globalLocale = data;\n            } else {\n                if (typeof console !== \"undefined\" && console.warn) {\n                    //warn user if arguments are passed but the locale could not be set\n                    console.warn(\"Locale \" + key + \" not found. Did you forget to load it?\");\n                }\n            }\n        }\n        return globalLocale._abbr;\n    }\n    function defineLocale(name, config) {\n        if (config !== null) {\n            var locale, parentConfig = baseConfig;\n            config.abbr = name;\n            if (locales[name] != null) {\n                deprecateSimple(\"defineLocaleOverride\", \"use moment.updateLocale(localeName, config) to change \" + \"an existing locale. moment.defineLocale(localeName, \" + \"config) should only be used for creating a new locale \" + \"See http://momentjs.com/guides/#/warnings/define-locale/ for more info.\");\n                parentConfig = locales[name]._config;\n            } else if (config.parentLocale != null) {\n                if (locales[config.parentLocale] != null) {\n                    parentConfig = locales[config.parentLocale]._config;\n                } else {\n                    locale = loadLocale(config.parentLocale);\n                    if (locale != null) {\n                        parentConfig = locale._config;\n                    } else {\n                        if (!localeFamilies[config.parentLocale]) {\n                            localeFamilies[config.parentLocale] = [];\n                        }\n                        localeFamilies[config.parentLocale].push({\n                            name: name,\n                            config: config\n                        });\n                        return null;\n                    }\n                }\n            }\n            locales[name] = new Locale(mergeConfigs(parentConfig, config));\n            if (localeFamilies[name]) {\n                localeFamilies[name].forEach(function(x) {\n                    defineLocale(x.name, x.config);\n                });\n            }\n            // backwards compat for now: also set the locale\n            // make sure we set the locale AFTER all child locales have been\n            // created, so we won't end up with the child locale set.\n            getSetGlobalLocale(name);\n            return locales[name];\n        } else {\n            // useful for testing\n            delete locales[name];\n            return null;\n        }\n    }\n    function updateLocale(name, config) {\n        if (config != null) {\n            var locale, tmpLocale, parentConfig = baseConfig;\n            if (locales[name] != null && locales[name].parentLocale != null) {\n                // Update existing child locale in-place to avoid memory-leaks\n                locales[name].set(mergeConfigs(locales[name]._config, config));\n            } else {\n                // MERGE\n                tmpLocale = loadLocale(name);\n                if (tmpLocale != null) {\n                    parentConfig = tmpLocale._config;\n                }\n                config = mergeConfigs(parentConfig, config);\n                if (tmpLocale == null) {\n                    // updateLocale is called for creating a new locale\n                    // Set abbr so it will have a name (getters return\n                    // undefined otherwise).\n                    config.abbr = name;\n                }\n                locale = new Locale(config);\n                locale.parentLocale = locales[name];\n                locales[name] = locale;\n            }\n            // backwards compat for now: also set the locale\n            getSetGlobalLocale(name);\n        } else {\n            // pass null for config to unupdate, useful for tests\n            if (locales[name] != null) {\n                if (locales[name].parentLocale != null) {\n                    locales[name] = locales[name].parentLocale;\n                    if (name === getSetGlobalLocale()) {\n                        getSetGlobalLocale(name);\n                    }\n                } else if (locales[name] != null) {\n                    delete locales[name];\n                }\n            }\n        }\n        return locales[name];\n    }\n    // returns locale data\n    function getLocale(key) {\n        var locale;\n        if (key && key._locale && key._locale._abbr) {\n            key = key._locale._abbr;\n        }\n        if (!key) {\n            return globalLocale;\n        }\n        if (!isArray(key)) {\n            //short-circuit everything else\n            locale = loadLocale(key);\n            if (locale) {\n                return locale;\n            }\n            key = [\n                key\n            ];\n        }\n        return chooseLocale(key);\n    }\n    function listLocales() {\n        return keys(locales);\n    }\n    function checkOverflow(m) {\n        var overflow, a = m._a;\n        if (a && getParsingFlags(m).overflow === -2) {\n            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;\n            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {\n                overflow = DATE;\n            }\n            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {\n                overflow = WEEK;\n            }\n            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {\n                overflow = WEEKDAY;\n            }\n            getParsingFlags(m).overflow = overflow;\n        }\n        return m;\n    }\n    // iso 8601 regex\n    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)\n    var extendedIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})-(?:\\d\\d-\\d\\d|W\\d\\d-\\d|W\\d\\d|\\d\\d\\d|\\d\\d))(?:(T| )(\\d\\d(?::\\d\\d(?::\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/, basicIsoRegex = /^\\s*((?:[+-]\\d{6}|\\d{4})(?:\\d\\d\\d\\d|W\\d\\d\\d|W\\d\\d|\\d\\d\\d|\\d\\d|))(?:(T| )(\\d\\d(?:\\d\\d(?:\\d\\d(?:[.,]\\d+)?)?)?)([+-]\\d\\d(?::?\\d\\d)?|\\s*Z)?)?$/, tzRegex = /Z|[+-]\\d\\d(?::?\\d\\d)?/, isoDates = [\n        [\n            \"YYYYYY-MM-DD\",\n            /[+-]\\d{6}-\\d\\d-\\d\\d/\n        ],\n        [\n            \"YYYY-MM-DD\",\n            /\\d{4}-\\d\\d-\\d\\d/\n        ],\n        [\n            \"GGGG-[W]WW-E\",\n            /\\d{4}-W\\d\\d-\\d/\n        ],\n        [\n            \"GGGG-[W]WW\",\n            /\\d{4}-W\\d\\d/,\n            false\n        ],\n        [\n            \"YYYY-DDD\",\n            /\\d{4}-\\d{3}/\n        ],\n        [\n            \"YYYY-MM\",\n            /\\d{4}-\\d\\d/,\n            false\n        ],\n        [\n            \"YYYYYYMMDD\",\n            /[+-]\\d{10}/\n        ],\n        [\n            \"YYYYMMDD\",\n            /\\d{8}/\n        ],\n        [\n            \"GGGG[W]WWE\",\n            /\\d{4}W\\d{3}/\n        ],\n        [\n            \"GGGG[W]WW\",\n            /\\d{4}W\\d{2}/,\n            false\n        ],\n        [\n            \"YYYYDDD\",\n            /\\d{7}/\n        ],\n        [\n            \"YYYYMM\",\n            /\\d{6}/,\n            false\n        ],\n        [\n            \"YYYY\",\n            /\\d{4}/,\n            false\n        ]\n    ], // iso time formats and regexes\n    isoTimes = [\n        [\n            \"HH:mm:ss.SSSS\",\n            /\\d\\d:\\d\\d:\\d\\d\\.\\d+/\n        ],\n        [\n            \"HH:mm:ss,SSSS\",\n            /\\d\\d:\\d\\d:\\d\\d,\\d+/\n        ],\n        [\n            \"HH:mm:ss\",\n            /\\d\\d:\\d\\d:\\d\\d/\n        ],\n        [\n            \"HH:mm\",\n            /\\d\\d:\\d\\d/\n        ],\n        [\n            \"HHmmss.SSSS\",\n            /\\d\\d\\d\\d\\d\\d\\.\\d+/\n        ],\n        [\n            \"HHmmss,SSSS\",\n            /\\d\\d\\d\\d\\d\\d,\\d+/\n        ],\n        [\n            \"HHmmss\",\n            /\\d\\d\\d\\d\\d\\d/\n        ],\n        [\n            \"HHmm\",\n            /\\d\\d\\d\\d/\n        ],\n        [\n            \"HH\",\n            /\\d\\d/\n        ]\n    ], aspNetJsonRegex = /^\\/?Date\\((-?\\d+)/i, // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3\n    rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\\s)?(\\d{1,2})\\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s(\\d{2,4})\\s(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\\d{4}))$/, obsOffsets = {\n        UT: 0,\n        GMT: 0,\n        EDT: -4 * 60,\n        EST: -5 * 60,\n        CDT: -5 * 60,\n        CST: -6 * 60,\n        MDT: -6 * 60,\n        MST: -7 * 60,\n        PDT: -7 * 60,\n        PST: -8 * 60\n    };\n    // date from iso format\n    function configFromISO(config) {\n        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;\n        if (match) {\n            getParsingFlags(config).iso = true;\n            for(i = 0, l = isoDatesLen; i < l; i++){\n                if (isoDates[i][1].exec(match[1])) {\n                    dateFormat = isoDates[i][0];\n                    allowTime = isoDates[i][2] !== false;\n                    break;\n                }\n            }\n            if (dateFormat == null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[3]) {\n                for(i = 0, l = isoTimesLen; i < l; i++){\n                    if (isoTimes[i][1].exec(match[3])) {\n                        // match[2] should be 'T' or space\n                        timeFormat = (match[2] || \" \") + isoTimes[i][0];\n                        break;\n                    }\n                }\n                if (timeFormat == null) {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            if (!allowTime && timeFormat != null) {\n                config._isValid = false;\n                return;\n            }\n            if (match[4]) {\n                if (tzRegex.exec(match[4])) {\n                    tzFormat = \"Z\";\n                } else {\n                    config._isValid = false;\n                    return;\n                }\n            }\n            config._f = dateFormat + (timeFormat || \"\") + (tzFormat || \"\");\n            configFromStringAndFormat(config);\n        } else {\n            config._isValid = false;\n        }\n    }\n    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {\n        var result = [\n            untruncateYear(yearStr),\n            defaultLocaleMonthsShort.indexOf(monthStr),\n            parseInt(dayStr, 10),\n            parseInt(hourStr, 10),\n            parseInt(minuteStr, 10)\n        ];\n        if (secondStr) {\n            result.push(parseInt(secondStr, 10));\n        }\n        return result;\n    }\n    function untruncateYear(yearStr) {\n        var year = parseInt(yearStr, 10);\n        if (year <= 49) {\n            return 2000 + year;\n        } else if (year <= 999) {\n            return 1900 + year;\n        }\n        return year;\n    }\n    function preprocessRFC2822(s) {\n        // Remove comments and folding whitespace and replace multiple-spaces with a single space\n        return s.replace(/\\([^()]*\\)|[\\n\\t]/g, \" \").replace(/(\\s\\s+)/g, \" \").replace(/^\\s\\s*/, \"\").replace(/\\s\\s*$/, \"\");\n    }\n    function checkWeekday(weekdayStr, parsedInput, config) {\n        if (weekdayStr) {\n            // TODO: Replace the vanilla JS Date object with an independent day-of-week check.\n            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();\n            if (weekdayProvided !== weekdayActual) {\n                getParsingFlags(config).weekdayMismatch = true;\n                config._isValid = false;\n                return false;\n            }\n        }\n        return true;\n    }\n    function calculateOffset(obsOffset, militaryOffset, numOffset) {\n        if (obsOffset) {\n            return obsOffsets[obsOffset];\n        } else if (militaryOffset) {\n            // the only allowed military tz is Z\n            return 0;\n        } else {\n            var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;\n            return h * 60 + m;\n        }\n    }\n    // date and time from ref 2822 format\n    function configFromRFC2822(config) {\n        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;\n        if (match) {\n            parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);\n            if (!checkWeekday(match[1], parsedArray, config)) {\n                return;\n            }\n            config._a = parsedArray;\n            config._tzm = calculateOffset(match[8], match[9], match[10]);\n            config._d = createUTCDate.apply(null, config._a);\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n            getParsingFlags(config).rfc2822 = true;\n        } else {\n            config._isValid = false;\n        }\n    }\n    // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict\n    function configFromString(config) {\n        var matched = aspNetJsonRegex.exec(config._i);\n        if (matched !== null) {\n            config._d = new Date(+matched[1]);\n            return;\n        }\n        configFromISO(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n        configFromRFC2822(config);\n        if (config._isValid === false) {\n            delete config._isValid;\n        } else {\n            return;\n        }\n        if (config._strict) {\n            config._isValid = false;\n        } else {\n            // Final attempt, use Input Fallback\n            hooks.createFromInputFallback(config);\n        }\n    }\n    hooks.createFromInputFallback = deprecate(\"value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), \" + \"which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are \" + \"discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.\", function(config) {\n        config._d = new Date(config._i + (config._useUTC ? \" UTC\" : \"\"));\n    });\n    // Pick the first defined of two or three arguments.\n    function defaults(a, b, c) {\n        if (a != null) {\n            return a;\n        }\n        if (b != null) {\n            return b;\n        }\n        return c;\n    }\n    function currentDateArray(config) {\n        // hooks is actually the exported moment object\n        var nowValue = new Date(hooks.now());\n        if (config._useUTC) {\n            return [\n                nowValue.getUTCFullYear(),\n                nowValue.getUTCMonth(),\n                nowValue.getUTCDate()\n            ];\n        }\n        return [\n            nowValue.getFullYear(),\n            nowValue.getMonth(),\n            nowValue.getDate()\n        ];\n    }\n    // convert an array to a date.\n    // the array should mirror the parameters below\n    // note: all values past the year are optional and will default to the lowest possible value.\n    // [year, month, day , hour, minute, second, millisecond]\n    function configFromArray(config) {\n        var i, date, input = [], currentDate, expectedWeekday, yearToUse;\n        if (config._d) {\n            return;\n        }\n        currentDate = currentDateArray(config);\n        //compute day of the year from weeks and weekdays\n        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {\n            dayOfYearFromWeekInfo(config);\n        }\n        //if the day of the year is set, figure out what it is\n        if (config._dayOfYear != null) {\n            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);\n            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {\n                getParsingFlags(config)._overflowDayOfYear = true;\n            }\n            date = createUTCDate(yearToUse, 0, config._dayOfYear);\n            config._a[MONTH] = date.getUTCMonth();\n            config._a[DATE] = date.getUTCDate();\n        }\n        // Default to current date.\n        // * if no year, month, day of month are given, default to today\n        // * if day of month is given, default month and year\n        // * if month is given, default only year\n        // * if year is given, don't default anything\n        for(i = 0; i < 3 && config._a[i] == null; ++i){\n            config._a[i] = input[i] = currentDate[i];\n        }\n        // Zero out whatever was not defaulted, including time\n        for(; i < 7; i++){\n            config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];\n        }\n        // Check for 24:00:00.000\n        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {\n            config._nextDay = true;\n            config._a[HOUR] = 0;\n        }\n        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);\n        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();\n        // Apply timezone offset from input. The actual utcOffset can be changed\n        // with parseZone.\n        if (config._tzm != null) {\n            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);\n        }\n        if (config._nextDay) {\n            config._a[HOUR] = 24;\n        }\n        // check for mismatching day of week\n        if (config._w && typeof config._w.d !== \"undefined\" && config._w.d !== expectedWeekday) {\n            getParsingFlags(config).weekdayMismatch = true;\n        }\n    }\n    function dayOfYearFromWeekInfo(config) {\n        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;\n        w = config._w;\n        if (w.GG != null || w.W != null || w.E != null) {\n            dow = 1;\n            doy = 4;\n            // TODO: We need to take the current isoWeekYear, but that depends on\n            // how we interpret now (local, utc, fixed offset). So create\n            // a now version of current config (take local/utc/offset flags, and\n            // create now).\n            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);\n            week = defaults(w.W, 1);\n            weekday = defaults(w.E, 1);\n            if (weekday < 1 || weekday > 7) {\n                weekdayOverflow = true;\n            }\n        } else {\n            dow = config._locale._week.dow;\n            doy = config._locale._week.doy;\n            curWeek = weekOfYear(createLocal(), dow, doy);\n            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);\n            // Default to current week.\n            week = defaults(w.w, curWeek.week);\n            if (w.d != null) {\n                // weekday -- low day numbers are considered next week\n                weekday = w.d;\n                if (weekday < 0 || weekday > 6) {\n                    weekdayOverflow = true;\n                }\n            } else if (w.e != null) {\n                // local weekday -- counting starts from beginning of week\n                weekday = w.e + dow;\n                if (w.e < 0 || w.e > 6) {\n                    weekdayOverflow = true;\n                }\n            } else {\n                // default to beginning of week\n                weekday = dow;\n            }\n        }\n        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {\n            getParsingFlags(config)._overflowWeeks = true;\n        } else if (weekdayOverflow != null) {\n            getParsingFlags(config)._overflowWeekday = true;\n        } else {\n            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);\n            config._a[YEAR] = temp.year;\n            config._dayOfYear = temp.dayOfYear;\n        }\n    }\n    // constant that refers to the ISO standard\n    hooks.ISO_8601 = function() {};\n    // constant that refers to the RFC 2822 form\n    hooks.RFC_2822 = function() {};\n    // date from string and format string\n    function configFromStringAndFormat(config) {\n        // TODO: Move this to another part of the creation flow to prevent circular deps\n        if (config._f === hooks.ISO_8601) {\n            configFromISO(config);\n            return;\n        }\n        if (config._f === hooks.RFC_2822) {\n            configFromRFC2822(config);\n            return;\n        }\n        config._a = [];\n        getParsingFlags(config).empty = true;\n        // This array is used to make a Date, either with `new Date` or `Date.UTC`\n        var string = \"\" + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;\n        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];\n        tokenLen = tokens.length;\n        for(i = 0; i < tokenLen; i++){\n            token = tokens[i];\n            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];\n            if (parsedInput) {\n                skipped = string.substr(0, string.indexOf(parsedInput));\n                if (skipped.length > 0) {\n                    getParsingFlags(config).unusedInput.push(skipped);\n                }\n                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);\n                totalParsedInputLength += parsedInput.length;\n            }\n            // don't parse if it's not a known token\n            if (formatTokenFunctions[token]) {\n                if (parsedInput) {\n                    getParsingFlags(config).empty = false;\n                } else {\n                    getParsingFlags(config).unusedTokens.push(token);\n                }\n                addTimeToArrayFromToken(token, parsedInput, config);\n            } else if (config._strict && !parsedInput) {\n                getParsingFlags(config).unusedTokens.push(token);\n            }\n        }\n        // add remaining unparsed input length to the string\n        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;\n        if (string.length > 0) {\n            getParsingFlags(config).unusedInput.push(string);\n        }\n        // clear _12h flag if hour is <= 12\n        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {\n            getParsingFlags(config).bigHour = undefined;\n        }\n        getParsingFlags(config).parsedDateParts = config._a.slice(0);\n        getParsingFlags(config).meridiem = config._meridiem;\n        // handle meridiem\n        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);\n        // handle era\n        era = getParsingFlags(config).era;\n        if (era !== null) {\n            config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);\n        }\n        configFromArray(config);\n        checkOverflow(config);\n    }\n    function meridiemFixWrap(locale, hour, meridiem) {\n        var isPm;\n        if (meridiem == null) {\n            // nothing to do\n            return hour;\n        }\n        if (locale.meridiemHour != null) {\n            return locale.meridiemHour(hour, meridiem);\n        } else if (locale.isPM != null) {\n            // Fallback\n            isPm = locale.isPM(meridiem);\n            if (isPm && hour < 12) {\n                hour += 12;\n            }\n            if (!isPm && hour === 12) {\n                hour = 0;\n            }\n            return hour;\n        } else {\n            // this is not supposed to happen\n            return hour;\n        }\n    }\n    // date from string and array of format strings\n    function configFromStringAndArray(config) {\n        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;\n        if (configfLen === 0) {\n            getParsingFlags(config).invalidFormat = true;\n            config._d = new Date(NaN);\n            return;\n        }\n        for(i = 0; i < configfLen; i++){\n            currentScore = 0;\n            validFormatFound = false;\n            tempConfig = copyConfig({}, config);\n            if (config._useUTC != null) {\n                tempConfig._useUTC = config._useUTC;\n            }\n            tempConfig._f = config._f[i];\n            configFromStringAndFormat(tempConfig);\n            if (isValid(tempConfig)) {\n                validFormatFound = true;\n            }\n            // if there is any input that was not parsed add a penalty for that format\n            currentScore += getParsingFlags(tempConfig).charsLeftOver;\n            //or tokens\n            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n            getParsingFlags(tempConfig).score = currentScore;\n            if (!bestFormatIsValid) {\n                if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {\n                    scoreToBeat = currentScore;\n                    bestMoment = tempConfig;\n                    if (validFormatFound) {\n                        bestFormatIsValid = true;\n                    }\n                }\n            } else {\n                if (currentScore < scoreToBeat) {\n                    scoreToBeat = currentScore;\n                    bestMoment = tempConfig;\n                }\n            }\n        }\n        extend(config, bestMoment || tempConfig);\n    }\n    function configFromObject(config) {\n        if (config._d) {\n            return;\n        }\n        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === undefined ? i.date : i.day;\n        config._a = map([\n            i.year,\n            i.month,\n            dayOrDate,\n            i.hour,\n            i.minute,\n            i.second,\n            i.millisecond\n        ], function(obj) {\n            return obj && parseInt(obj, 10);\n        });\n        configFromArray(config);\n    }\n    function createFromConfig(config) {\n        var res = new Moment(checkOverflow(prepareConfig(config)));\n        if (res._nextDay) {\n            // Adding is smart enough around DST\n            res.add(1, \"d\");\n            res._nextDay = undefined;\n        }\n        return res;\n    }\n    function prepareConfig(config) {\n        var input = config._i, format = config._f;\n        config._locale = config._locale || getLocale(config._l);\n        if (input === null || format === undefined && input === \"\") {\n            return createInvalid({\n                nullInput: true\n            });\n        }\n        if (typeof input === \"string\") {\n            config._i = input = config._locale.preparse(input);\n        }\n        if (isMoment(input)) {\n            return new Moment(checkOverflow(input));\n        } else if (isDate(input)) {\n            config._d = input;\n        } else if (isArray(format)) {\n            configFromStringAndArray(config);\n        } else if (format) {\n            configFromStringAndFormat(config);\n        } else {\n            configFromInput(config);\n        }\n        if (!isValid(config)) {\n            config._d = null;\n        }\n        return config;\n    }\n    function configFromInput(config) {\n        var input = config._i;\n        if (isUndefined(input)) {\n            config._d = new Date(hooks.now());\n        } else if (isDate(input)) {\n            config._d = new Date(input.valueOf());\n        } else if (typeof input === \"string\") {\n            configFromString(config);\n        } else if (isArray(input)) {\n            config._a = map(input.slice(0), function(obj) {\n                return parseInt(obj, 10);\n            });\n            configFromArray(config);\n        } else if (isObject(input)) {\n            configFromObject(config);\n        } else if (isNumber(input)) {\n            // from milliseconds\n            config._d = new Date(input);\n        } else {\n            hooks.createFromInputFallback(config);\n        }\n    }\n    function createLocalOrUTC(input, format, locale, strict, isUTC) {\n        var c = {};\n        if (format === true || format === false) {\n            strict = format;\n            format = undefined;\n        }\n        if (locale === true || locale === false) {\n            strict = locale;\n            locale = undefined;\n        }\n        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {\n            input = undefined;\n        }\n        // object construction must be done this way.\n        // https://github.com/moment/moment/issues/1423\n        c._isAMomentObject = true;\n        c._useUTC = c._isUTC = isUTC;\n        c._l = locale;\n        c._i = input;\n        c._f = format;\n        c._strict = strict;\n        return createFromConfig(c);\n    }\n    function createLocal(input, format, locale, strict) {\n        return createLocalOrUTC(input, format, locale, strict, false);\n    }\n    var prototypeMin = deprecate(\"moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/\", function() {\n        var other = createLocal.apply(null, arguments);\n        if (this.isValid() && other.isValid()) {\n            return other < this ? this : other;\n        } else {\n            return createInvalid();\n        }\n    }), prototypeMax = deprecate(\"moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/\", function() {\n        var other = createLocal.apply(null, arguments);\n        if (this.isValid() && other.isValid()) {\n            return other > this ? this : other;\n        } else {\n            return createInvalid();\n        }\n    });\n    // Pick a moment m from moments so that m[fn](other) is true for all\n    // other. This relies on the function fn to be transitive.\n    //\n    // moments should either be an array of moment objects or an array, whose\n    // first element is an array of moment objects.\n    function pickBy(fn, moments) {\n        var res, i;\n        if (moments.length === 1 && isArray(moments[0])) {\n            moments = moments[0];\n        }\n        if (!moments.length) {\n            return createLocal();\n        }\n        res = moments[0];\n        for(i = 1; i < moments.length; ++i){\n            if (!moments[i].isValid() || moments[i][fn](res)) {\n                res = moments[i];\n            }\n        }\n        return res;\n    }\n    // TODO: Use [].sort instead?\n    function min() {\n        var args = [].slice.call(arguments, 0);\n        return pickBy(\"isBefore\", args);\n    }\n    function max() {\n        var args = [].slice.call(arguments, 0);\n        return pickBy(\"isAfter\", args);\n    }\n    var now = function() {\n        return Date.now ? Date.now() : +new Date();\n    };\n    var ordering = [\n        \"year\",\n        \"quarter\",\n        \"month\",\n        \"week\",\n        \"day\",\n        \"hour\",\n        \"minute\",\n        \"second\",\n        \"millisecond\"\n    ];\n    function isDurationValid(m) {\n        var key, unitHasDecimal = false, i, orderLen = ordering.length;\n        for(key in m){\n            if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {\n                return false;\n            }\n        }\n        for(i = 0; i < orderLen; ++i){\n            if (m[ordering[i]]) {\n                if (unitHasDecimal) {\n                    return false; // only allow non-integers for smallest unit\n                }\n                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {\n                    unitHasDecimal = true;\n                }\n            }\n        }\n        return true;\n    }\n    function isValid$1() {\n        return this._isValid;\n    }\n    function createInvalid$1() {\n        return createDuration(NaN);\n    }\n    function Duration(duration) {\n        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || normalizedInput.isoWeek || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;\n        this._isValid = isDurationValid(normalizedInput);\n        // representation for dateAddRemove\n        this._milliseconds = +milliseconds + seconds * 1e3 + // 1000\n        minutes * 6e4 + // 1000 * 60\n        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978\n        // Because of dateAddRemove treats 24 hours as different from a\n        // day when working around DST, we need to store them separately\n        this._days = +days + weeks * 7;\n        // It is impossible to translate months into days without knowing\n        // which months you are are talking about, so we have to store\n        // it separately.\n        this._months = +months + quarters * 3 + years * 12;\n        this._data = {};\n        this._locale = getLocale();\n        this._bubble();\n    }\n    function isDuration(obj) {\n        return obj instanceof Duration;\n    }\n    function absRound(number) {\n        if (number < 0) {\n            return Math.round(-1 * number) * -1;\n        } else {\n            return Math.round(number);\n        }\n    }\n    // compare two arrays, return the number of differences\n    function compareArrays(array1, array2, dontConvert) {\n        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;\n        for(i = 0; i < len; i++){\n            if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {\n                diffs++;\n            }\n        }\n        return diffs + lengthDiff;\n    }\n    // FORMATTING\n    function offset(token, separator) {\n        addFormatToken(token, 0, 0, function() {\n            var offset = this.utcOffset(), sign = \"+\";\n            if (offset < 0) {\n                offset = -offset;\n                sign = \"-\";\n            }\n            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);\n        });\n    }\n    offset(\"Z\", \":\");\n    offset(\"ZZ\", \"\");\n    // PARSING\n    addRegexToken(\"Z\", matchShortOffset);\n    addRegexToken(\"ZZ\", matchShortOffset);\n    addParseToken([\n        \"Z\",\n        \"ZZ\"\n    ], function(input, array, config) {\n        config._useUTC = true;\n        config._tzm = offsetFromString(matchShortOffset, input);\n    });\n    // HELPERS\n    // timezone chunker\n    // '+10:00' > ['10',  '00']\n    // '-1530'  > ['-15', '30']\n    var chunkOffset = /([\\+\\-]|\\d\\d)/gi;\n    function offsetFromString(matcher, string) {\n        var matches = (string || \"\").match(matcher), chunk, parts, minutes;\n        if (matches === null) {\n            return null;\n        }\n        chunk = matches[matches.length - 1] || [];\n        parts = (chunk + \"\").match(chunkOffset) || [\n            \"-\",\n            0,\n            0\n        ];\n        minutes = +(parts[1] * 60) + toInt(parts[2]);\n        return minutes === 0 ? 0 : parts[0] === \"+\" ? minutes : -minutes;\n    }\n    // Return a moment from input, that is local/utc/zone equivalent to model.\n    function cloneWithOffset(input, model) {\n        var res, diff;\n        if (model._isUTC) {\n            res = model.clone();\n            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();\n            // Use low-level api, because this fn is low-level api.\n            res._d.setTime(res._d.valueOf() + diff);\n            hooks.updateOffset(res, false);\n            return res;\n        } else {\n            return createLocal(input).local();\n        }\n    }\n    function getDateOffset(m) {\n        // On Firefox.24 Date#getTimezoneOffset returns a floating point.\n        // https://github.com/moment/moment/pull/1871\n        return -Math.round(m._d.getTimezoneOffset());\n    }\n    // HOOKS\n    // This function will be called whenever a moment is mutated.\n    // It is intended to keep the offset in sync with the timezone.\n    hooks.updateOffset = function() {};\n    // MOMENTS\n    // keepLocalTime = true means only change the timezone, without\n    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->\n    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset\n    // +0200, so we adjust the time as needed, to be valid.\n    //\n    // Keeping the time actually adds/subtracts (one hour)\n    // from the actual represented time. That is why we call updateOffset\n    // a second time. In case it wants us to change the offset again\n    // _changeInProgress == true case, then we have to adjust, because\n    // there is no such time in the given timezone.\n    function getSetOffset(input, keepLocalTime, keepMinutes) {\n        var offset = this._offset || 0, localAdjust;\n        if (!this.isValid()) {\n            return input != null ? this : NaN;\n        }\n        if (input != null) {\n            if (typeof input === \"string\") {\n                input = offsetFromString(matchShortOffset, input);\n                if (input === null) {\n                    return this;\n                }\n            } else if (Math.abs(input) < 16 && !keepMinutes) {\n                input = input * 60;\n            }\n            if (!this._isUTC && keepLocalTime) {\n                localAdjust = getDateOffset(this);\n            }\n            this._offset = input;\n            this._isUTC = true;\n            if (localAdjust != null) {\n                this.add(localAdjust, \"m\");\n            }\n            if (offset !== input) {\n                if (!keepLocalTime || this._changeInProgress) {\n                    addSubtract(this, createDuration(input - offset, \"m\"), 1, false);\n                } else if (!this._changeInProgress) {\n                    this._changeInProgress = true;\n                    hooks.updateOffset(this, true);\n                    this._changeInProgress = null;\n                }\n            }\n            return this;\n        } else {\n            return this._isUTC ? offset : getDateOffset(this);\n        }\n    }\n    function getSetZone(input, keepLocalTime) {\n        if (input != null) {\n            if (typeof input !== \"string\") {\n                input = -input;\n            }\n            this.utcOffset(input, keepLocalTime);\n            return this;\n        } else {\n            return -this.utcOffset();\n        }\n    }\n    function setOffsetToUTC(keepLocalTime) {\n        return this.utcOffset(0, keepLocalTime);\n    }\n    function setOffsetToLocal(keepLocalTime) {\n        if (this._isUTC) {\n            this.utcOffset(0, keepLocalTime);\n            this._isUTC = false;\n            if (keepLocalTime) {\n                this.subtract(getDateOffset(this), \"m\");\n            }\n        }\n        return this;\n    }\n    function setOffsetToParsedOffset() {\n        if (this._tzm != null) {\n            this.utcOffset(this._tzm, false, true);\n        } else if (typeof this._i === \"string\") {\n            var tZone = offsetFromString(matchOffset, this._i);\n            if (tZone != null) {\n                this.utcOffset(tZone);\n            } else {\n                this.utcOffset(0, true);\n            }\n        }\n        return this;\n    }\n    function hasAlignedHourOffset(input) {\n        if (!this.isValid()) {\n            return false;\n        }\n        input = input ? createLocal(input).utcOffset() : 0;\n        return (this.utcOffset() - input) % 60 === 0;\n    }\n    function isDaylightSavingTime() {\n        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();\n    }\n    function isDaylightSavingTimeShifted() {\n        if (!isUndefined(this._isDSTShifted)) {\n            return this._isDSTShifted;\n        }\n        var c = {}, other;\n        copyConfig(c, this);\n        c = prepareConfig(c);\n        if (c._a) {\n            other = c._isUTC ? createUTC(c._a) : createLocal(c._a);\n            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;\n        } else {\n            this._isDSTShifted = false;\n        }\n        return this._isDSTShifted;\n    }\n    function isLocal() {\n        return this.isValid() ? !this._isUTC : false;\n    }\n    function isUtcOffset() {\n        return this.isValid() ? this._isUTC : false;\n    }\n    function isUtc() {\n        return this.isValid() ? this._isUTC && this._offset === 0 : false;\n    }\n    // ASP.NET json date format regex\n    var aspNetRegex = /^(-|\\+)?(?:(\\d*)[. ])?(\\d+):(\\d+)(?::(\\d+)(\\.\\d*)?)?$/, // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html\n    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere\n    // and further modified to allow for strings containing both week and day\n    isoRegex = /^(-|\\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;\n    function createDuration(input, key) {\n        var duration = input, // matching against regexp is expensive, do it on demand\n        match = null, sign, ret, diffRes;\n        if (isDuration(input)) {\n            duration = {\n                ms: input._milliseconds,\n                d: input._days,\n                M: input._months\n            };\n        } else if (isNumber(input) || !isNaN(+input)) {\n            duration = {};\n            if (key) {\n                duration[key] = +input;\n            } else {\n                duration.milliseconds = +input;\n            }\n        } else if (match = aspNetRegex.exec(input)) {\n            sign = match[1] === \"-\" ? -1 : 1;\n            duration = {\n                y: 0,\n                d: toInt(match[DATE]) * sign,\n                h: toInt(match[HOUR]) * sign,\n                m: toInt(match[MINUTE]) * sign,\n                s: toInt(match[SECOND]) * sign,\n                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign\n            };\n        } else if (match = isoRegex.exec(input)) {\n            sign = match[1] === \"-\" ? -1 : 1;\n            duration = {\n                y: parseIso(match[2], sign),\n                M: parseIso(match[3], sign),\n                w: parseIso(match[4], sign),\n                d: parseIso(match[5], sign),\n                h: parseIso(match[6], sign),\n                m: parseIso(match[7], sign),\n                s: parseIso(match[8], sign)\n            };\n        } else if (duration == null) {\n            // checks for null or undefined\n            duration = {};\n        } else if (typeof duration === \"object\" && (\"from\" in duration || \"to\" in duration)) {\n            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));\n            duration = {};\n            duration.ms = diffRes.milliseconds;\n            duration.M = diffRes.months;\n        }\n        ret = new Duration(duration);\n        if (isDuration(input) && hasOwnProp(input, \"_locale\")) {\n            ret._locale = input._locale;\n        }\n        if (isDuration(input) && hasOwnProp(input, \"_isValid\")) {\n            ret._isValid = input._isValid;\n        }\n        return ret;\n    }\n    createDuration.fn = Duration.prototype;\n    createDuration.invalid = createInvalid$1;\n    function parseIso(inp, sign) {\n        // We'd normally use ~~inp for this, but unfortunately it also\n        // converts floats to ints.\n        // inp may be undefined, so careful calling replace on it.\n        var res = inp && parseFloat(inp.replace(\",\", \".\"));\n        // apply sign while we're at it\n        return (isNaN(res) ? 0 : res) * sign;\n    }\n    function positiveMomentsDifference(base, other) {\n        var res = {};\n        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;\n        if (base.clone().add(res.months, \"M\").isAfter(other)) {\n            --res.months;\n        }\n        res.milliseconds = +other - +base.clone().add(res.months, \"M\");\n        return res;\n    }\n    function momentsDifference(base, other) {\n        var res;\n        if (!(base.isValid() && other.isValid())) {\n            return {\n                milliseconds: 0,\n                months: 0\n            };\n        }\n        other = cloneWithOffset(other, base);\n        if (base.isBefore(other)) {\n            res = positiveMomentsDifference(base, other);\n        } else {\n            res = positiveMomentsDifference(other, base);\n            res.milliseconds = -res.milliseconds;\n            res.months = -res.months;\n        }\n        return res;\n    }\n    // TODO: remove 'name' arg after deprecation is removed\n    function createAdder(direction, name) {\n        return function(val, period) {\n            var dur, tmp;\n            //invert the arguments, but complain about it\n            if (period !== null && !isNaN(+period)) {\n                deprecateSimple(name, \"moment().\" + name + \"(period, number) is deprecated. Please use moment().\" + name + \"(number, period). \" + \"See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.\");\n                tmp = val;\n                val = period;\n                period = tmp;\n            }\n            dur = createDuration(val, period);\n            addSubtract(this, dur, direction);\n            return this;\n        };\n    }\n    function addSubtract(mom, duration, isAdding, updateOffset) {\n        var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);\n        if (!mom.isValid()) {\n            // No op\n            return;\n        }\n        updateOffset = updateOffset == null ? true : updateOffset;\n        if (months) {\n            setMonth(mom, get(mom, \"Month\") + months * isAdding);\n        }\n        if (days) {\n            set$1(mom, \"Date\", get(mom, \"Date\") + days * isAdding);\n        }\n        if (milliseconds) {\n            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);\n        }\n        if (updateOffset) {\n            hooks.updateOffset(mom, days || months);\n        }\n    }\n    var add = createAdder(1, \"add\"), subtract = createAdder(-1, \"subtract\");\n    function isString(input) {\n        return typeof input === \"string\" || input instanceof String;\n    }\n    // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined\n    function isMomentInput(input) {\n        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;\n    }\n    function isMomentInputObject(input) {\n        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [\n            \"years\",\n            \"year\",\n            \"y\",\n            \"months\",\n            \"month\",\n            \"M\",\n            \"days\",\n            \"day\",\n            \"d\",\n            \"dates\",\n            \"date\",\n            \"D\",\n            \"hours\",\n            \"hour\",\n            \"h\",\n            \"minutes\",\n            \"minute\",\n            \"m\",\n            \"seconds\",\n            \"second\",\n            \"s\",\n            \"milliseconds\",\n            \"millisecond\",\n            \"ms\"\n        ], i, property, propertyLen = properties.length;\n        for(i = 0; i < propertyLen; i += 1){\n            property = properties[i];\n            propertyTest = propertyTest || hasOwnProp(input, property);\n        }\n        return objectTest && propertyTest;\n    }\n    function isNumberOrStringArray(input) {\n        var arrayTest = isArray(input), dataTypeTest = false;\n        if (arrayTest) {\n            dataTypeTest = input.filter(function(item) {\n                return !isNumber(item) && isString(input);\n            }).length === 0;\n        }\n        return arrayTest && dataTypeTest;\n    }\n    function isCalendarSpec(input) {\n        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [\n            \"sameDay\",\n            \"nextDay\",\n            \"lastDay\",\n            \"nextWeek\",\n            \"lastWeek\",\n            \"sameElse\"\n        ], i, property;\n        for(i = 0; i < properties.length; i += 1){\n            property = properties[i];\n            propertyTest = propertyTest || hasOwnProp(input, property);\n        }\n        return objectTest && propertyTest;\n    }\n    function getCalendarFormat(myMoment, now) {\n        var diff = myMoment.diff(now, \"days\", true);\n        return diff < -6 ? \"sameElse\" : diff < -1 ? \"lastWeek\" : diff < 0 ? \"lastDay\" : diff < 1 ? \"sameDay\" : diff < 2 ? \"nextDay\" : diff < 7 ? \"nextWeek\" : \"sameElse\";\n    }\n    function calendar$1(time, formats) {\n        // Support for single parameter, formats only overload to the calendar function\n        if (arguments.length === 1) {\n            if (!arguments[0]) {\n                time = undefined;\n                formats = undefined;\n            } else if (isMomentInput(arguments[0])) {\n                time = arguments[0];\n                formats = undefined;\n            } else if (isCalendarSpec(arguments[0])) {\n                formats = arguments[0];\n                time = undefined;\n            }\n        }\n        // We want to compare the start of today, vs this.\n        // Getting start-of-today depends on whether we're local/utc/offset or not.\n        var now = time || createLocal(), sod = cloneWithOffset(now, this).startOf(\"day\"), format = hooks.calendarFormat(this, sod) || \"sameElse\", output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);\n        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));\n    }\n    function clone() {\n        return new Moment(this);\n    }\n    function isAfter(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || \"millisecond\";\n        if (units === \"millisecond\") {\n            return this.valueOf() > localInput.valueOf();\n        } else {\n            return localInput.valueOf() < this.clone().startOf(units).valueOf();\n        }\n    }\n    function isBefore(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input);\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || \"millisecond\";\n        if (units === \"millisecond\") {\n            return this.valueOf() < localInput.valueOf();\n        } else {\n            return this.clone().endOf(units).valueOf() < localInput.valueOf();\n        }\n    }\n    function isBetween(from, to, units, inclusivity) {\n        var localFrom = isMoment(from) ? from : createLocal(from), localTo = isMoment(to) ? to : createLocal(to);\n        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {\n            return false;\n        }\n        inclusivity = inclusivity || \"()\";\n        return (inclusivity[0] === \"(\" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === \")\" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));\n    }\n    function isSame(input, units) {\n        var localInput = isMoment(input) ? input : createLocal(input), inputMs;\n        if (!(this.isValid() && localInput.isValid())) {\n            return false;\n        }\n        units = normalizeUnits(units) || \"millisecond\";\n        if (units === \"millisecond\") {\n            return this.valueOf() === localInput.valueOf();\n        } else {\n            inputMs = localInput.valueOf();\n            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();\n        }\n    }\n    function isSameOrAfter(input, units) {\n        return this.isSame(input, units) || this.isAfter(input, units);\n    }\n    function isSameOrBefore(input, units) {\n        return this.isSame(input, units) || this.isBefore(input, units);\n    }\n    function diff(input, units, asFloat) {\n        var that, zoneDelta, output;\n        if (!this.isValid()) {\n            return NaN;\n        }\n        that = cloneWithOffset(input, this);\n        if (!that.isValid()) {\n            return NaN;\n        }\n        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;\n        units = normalizeUnits(units);\n        switch(units){\n            case \"year\":\n                output = monthDiff(this, that) / 12;\n                break;\n            case \"month\":\n                output = monthDiff(this, that);\n                break;\n            case \"quarter\":\n                output = monthDiff(this, that) / 3;\n                break;\n            case \"second\":\n                output = (this - that) / 1e3;\n                break; // 1000\n            case \"minute\":\n                output = (this - that) / 6e4;\n                break; // 1000 * 60\n            case \"hour\":\n                output = (this - that) / 36e5;\n                break; // 1000 * 60 * 60\n            case \"day\":\n                output = (this - that - zoneDelta) / 864e5;\n                break; // 1000 * 60 * 60 * 24, negate dst\n            case \"week\":\n                output = (this - that - zoneDelta) / 6048e5;\n                break; // 1000 * 60 * 60 * 24 * 7, negate dst\n            default:\n                output = this - that;\n        }\n        return asFloat ? output : absFloor(output);\n    }\n    function monthDiff(a, b) {\n        if (a.date() < b.date()) {\n            // end-of-month calculations work correct when the start month has more\n            // days than the end month.\n            return -monthDiff(b, a);\n        }\n        // difference in months\n        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), // b is in (anchor - 1 month, anchor + 1 month)\n        anchor = a.clone().add(wholeMonthDiff, \"months\"), anchor2, adjust;\n        if (b - anchor < 0) {\n            anchor2 = a.clone().add(wholeMonthDiff - 1, \"months\");\n            // linear across the month\n            adjust = (b - anchor) / (anchor - anchor2);\n        } else {\n            anchor2 = a.clone().add(wholeMonthDiff + 1, \"months\");\n            // linear across the month\n            adjust = (b - anchor) / (anchor2 - anchor);\n        }\n        //check for negative zero, return zero if negative zero\n        return -(wholeMonthDiff + adjust) || 0;\n    }\n    hooks.defaultFormat = \"YYYY-MM-DDTHH:mm:ssZ\";\n    hooks.defaultFormatUtc = \"YYYY-MM-DDTHH:mm:ss[Z]\";\n    function toString() {\n        return this.clone().locale(\"en\").format(\"ddd MMM DD YYYY HH:mm:ss [GMT]ZZ\");\n    }\n    function toISOString(keepOffset) {\n        if (!this.isValid()) {\n            return null;\n        }\n        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;\n        if (m.year() < 0 || m.year() > 9999) {\n            return formatMoment(m, utc ? \"YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]\" : \"YYYYYY-MM-DD[T]HH:mm:ss.SSSZ\");\n        }\n        if (isFunction(Date.prototype.toISOString)) {\n            // native implementation is ~50x faster, use it when we can\n            if (utc) {\n                return this.toDate().toISOString();\n            } else {\n                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace(\"Z\", formatMoment(m, \"Z\"));\n            }\n        }\n        return formatMoment(m, utc ? \"YYYY-MM-DD[T]HH:mm:ss.SSS[Z]\" : \"YYYY-MM-DD[T]HH:mm:ss.SSSZ\");\n    }\n    /**\n     * Return a human readable representation of a moment that can\n     * also be evaluated to get a new moment which is the same\n     *\n     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects\n     */ function inspect() {\n        if (!this.isValid()) {\n            return \"moment.invalid(/* \" + this._i + \" */)\";\n        }\n        var func = \"moment\", zone = \"\", prefix, year, datetime, suffix;\n        if (!this.isLocal()) {\n            func = this.utcOffset() === 0 ? \"moment.utc\" : \"moment.parseZone\";\n            zone = \"Z\";\n        }\n        prefix = \"[\" + func + '(\"]';\n        year = 0 <= this.year() && this.year() <= 9999 ? \"YYYY\" : \"YYYYYY\";\n        datetime = \"-MM-DD[T]HH:mm:ss.SSS\";\n        suffix = zone + '[\")]';\n        return this.format(prefix + year + datetime + suffix);\n    }\n    function format(inputString) {\n        if (!inputString) {\n            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;\n        }\n        var output = formatMoment(this, inputString);\n        return this.localeData().postformat(output);\n    }\n    function from(time, withoutSuffix) {\n        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {\n            return createDuration({\n                to: this,\n                from: time\n            }).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n    function fromNow(withoutSuffix) {\n        return this.from(createLocal(), withoutSuffix);\n    }\n    function to(time, withoutSuffix) {\n        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {\n            return createDuration({\n                from: this,\n                to: time\n            }).locale(this.locale()).humanize(!withoutSuffix);\n        } else {\n            return this.localeData().invalidDate();\n        }\n    }\n    function toNow(withoutSuffix) {\n        return this.to(createLocal(), withoutSuffix);\n    }\n    // If passed a locale key, it will set the locale for this\n    // instance.  Otherwise, it will return the locale configuration\n    // variables for this instance.\n    function locale(key) {\n        var newLocaleData;\n        if (key === undefined) {\n            return this._locale._abbr;\n        } else {\n            newLocaleData = getLocale(key);\n            if (newLocaleData != null) {\n                this._locale = newLocaleData;\n            }\n            return this;\n        }\n    }\n    var lang = deprecate(\"moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.\", function(key) {\n        if (key === undefined) {\n            return this.localeData();\n        } else {\n            return this.locale(key);\n        }\n    });\n    function localeData() {\n        return this._locale;\n    }\n    var MS_PER_SECOND = 1000, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;\n    // actual modulo - handles negative numbers (for dates before 1970):\n    function mod$1(dividend, divisor) {\n        return (dividend % divisor + divisor) % divisor;\n    }\n    function localStartOfDate(y, m, d) {\n        // the date constructor remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            return new Date(y + 400, m, d) - MS_PER_400_YEARS;\n        } else {\n            return new Date(y, m, d).valueOf();\n        }\n    }\n    function utcStartOfDate(y, m, d) {\n        // Date.UTC remaps years 0-99 to 1900-1999\n        if (y < 100 && y >= 0) {\n            // preserve leap years using a full 400 year cycle, then reset\n            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;\n        } else {\n            return Date.UTC(y, m, d);\n        }\n    }\n    function startOf(units) {\n        var time, startOfDate;\n        units = normalizeUnits(units);\n        if (units === undefined || units === \"millisecond\" || !this.isValid()) {\n            return this;\n        }\n        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n        switch(units){\n            case \"year\":\n                time = startOfDate(this.year(), 0, 1);\n                break;\n            case \"quarter\":\n                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);\n                break;\n            case \"month\":\n                time = startOfDate(this.year(), this.month(), 1);\n                break;\n            case \"week\":\n                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());\n                break;\n            case \"isoWeek\":\n                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));\n                break;\n            case \"day\":\n            case \"date\":\n                time = startOfDate(this.year(), this.month(), this.date());\n                break;\n            case \"hour\":\n                time = this._d.valueOf();\n                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);\n                break;\n            case \"minute\":\n                time = this._d.valueOf();\n                time -= mod$1(time, MS_PER_MINUTE);\n                break;\n            case \"second\":\n                time = this._d.valueOf();\n                time -= mod$1(time, MS_PER_SECOND);\n                break;\n        }\n        this._d.setTime(time);\n        hooks.updateOffset(this, true);\n        return this;\n    }\n    function endOf(units) {\n        var time, startOfDate;\n        units = normalizeUnits(units);\n        if (units === undefined || units === \"millisecond\" || !this.isValid()) {\n            return this;\n        }\n        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;\n        switch(units){\n            case \"year\":\n                time = startOfDate(this.year() + 1, 0, 1) - 1;\n                break;\n            case \"quarter\":\n                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;\n                break;\n            case \"month\":\n                time = startOfDate(this.year(), this.month() + 1, 1) - 1;\n                break;\n            case \"week\":\n                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;\n                break;\n            case \"isoWeek\":\n                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;\n                break;\n            case \"day\":\n            case \"date\":\n                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;\n                break;\n            case \"hour\":\n                time = this._d.valueOf();\n                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;\n                break;\n            case \"minute\":\n                time = this._d.valueOf();\n                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;\n                break;\n            case \"second\":\n                time = this._d.valueOf();\n                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;\n                break;\n        }\n        this._d.setTime(time);\n        hooks.updateOffset(this, true);\n        return this;\n    }\n    function valueOf() {\n        return this._d.valueOf() - (this._offset || 0) * 60000;\n    }\n    function unix() {\n        return Math.floor(this.valueOf() / 1000);\n    }\n    function toDate() {\n        return new Date(this.valueOf());\n    }\n    function toArray() {\n        var m = this;\n        return [\n            m.year(),\n            m.month(),\n            m.date(),\n            m.hour(),\n            m.minute(),\n            m.second(),\n            m.millisecond()\n        ];\n    }\n    function toObject() {\n        var m = this;\n        return {\n            years: m.year(),\n            months: m.month(),\n            date: m.date(),\n            hours: m.hours(),\n            minutes: m.minutes(),\n            seconds: m.seconds(),\n            milliseconds: m.milliseconds()\n        };\n    }\n    function toJSON() {\n        // new Date(NaN).toJSON() === null\n        return this.isValid() ? this.toISOString() : null;\n    }\n    function isValid$2() {\n        return isValid(this);\n    }\n    function parsingFlags() {\n        return extend({}, getParsingFlags(this));\n    }\n    function invalidAt() {\n        return getParsingFlags(this).overflow;\n    }\n    function creationData() {\n        return {\n            input: this._i,\n            format: this._f,\n            locale: this._locale,\n            isUTC: this._isUTC,\n            strict: this._strict\n        };\n    }\n    addFormatToken(\"N\", 0, 0, \"eraAbbr\");\n    addFormatToken(\"NN\", 0, 0, \"eraAbbr\");\n    addFormatToken(\"NNN\", 0, 0, \"eraAbbr\");\n    addFormatToken(\"NNNN\", 0, 0, \"eraName\");\n    addFormatToken(\"NNNNN\", 0, 0, \"eraNarrow\");\n    addFormatToken(\"y\", [\n        \"y\",\n        1\n    ], \"yo\", \"eraYear\");\n    addFormatToken(\"y\", [\n        \"yy\",\n        2\n    ], 0, \"eraYear\");\n    addFormatToken(\"y\", [\n        \"yyy\",\n        3\n    ], 0, \"eraYear\");\n    addFormatToken(\"y\", [\n        \"yyyy\",\n        4\n    ], 0, \"eraYear\");\n    addRegexToken(\"N\", matchEraAbbr);\n    addRegexToken(\"NN\", matchEraAbbr);\n    addRegexToken(\"NNN\", matchEraAbbr);\n    addRegexToken(\"NNNN\", matchEraName);\n    addRegexToken(\"NNNNN\", matchEraNarrow);\n    addParseToken([\n        \"N\",\n        \"NN\",\n        \"NNN\",\n        \"NNNN\",\n        \"NNNNN\"\n    ], function(input, array, config, token) {\n        var era = config._locale.erasParse(input, token, config._strict);\n        if (era) {\n            getParsingFlags(config).era = era;\n        } else {\n            getParsingFlags(config).invalidEra = input;\n        }\n    });\n    addRegexToken(\"y\", matchUnsigned);\n    addRegexToken(\"yy\", matchUnsigned);\n    addRegexToken(\"yyy\", matchUnsigned);\n    addRegexToken(\"yyyy\", matchUnsigned);\n    addRegexToken(\"yo\", matchEraYearOrdinal);\n    addParseToken([\n        \"y\",\n        \"yy\",\n        \"yyy\",\n        \"yyyy\"\n    ], YEAR);\n    addParseToken([\n        \"yo\"\n    ], function(input, array, config, token) {\n        var match;\n        if (config._locale._eraYearOrdinalRegex) {\n            match = input.match(config._locale._eraYearOrdinalRegex);\n        }\n        if (config._locale.eraYearOrdinalParse) {\n            array[YEAR] = config._locale.eraYearOrdinalParse(input, match);\n        } else {\n            array[YEAR] = parseInt(input, 10);\n        }\n    });\n    function localeEras(m, format) {\n        var i, l, date, eras = this._eras || getLocale(\"en\")._eras;\n        for(i = 0, l = eras.length; i < l; ++i){\n            switch(typeof eras[i].since){\n                case \"string\":\n                    // truncate time\n                    date = hooks(eras[i].since).startOf(\"day\");\n                    eras[i].since = date.valueOf();\n                    break;\n            }\n            switch(typeof eras[i].until){\n                case \"undefined\":\n                    eras[i].until = +Infinity;\n                    break;\n                case \"string\":\n                    // truncate time\n                    date = hooks(eras[i].until).startOf(\"day\").valueOf();\n                    eras[i].until = date.valueOf();\n                    break;\n            }\n        }\n        return eras;\n    }\n    function localeErasParse(eraName, format, strict) {\n        var i, l, eras = this.eras(), name, abbr, narrow;\n        eraName = eraName.toUpperCase();\n        for(i = 0, l = eras.length; i < l; ++i){\n            name = eras[i].name.toUpperCase();\n            abbr = eras[i].abbr.toUpperCase();\n            narrow = eras[i].narrow.toUpperCase();\n            if (strict) {\n                switch(format){\n                    case \"N\":\n                    case \"NN\":\n                    case \"NNN\":\n                        if (abbr === eraName) {\n                            return eras[i];\n                        }\n                        break;\n                    case \"NNNN\":\n                        if (name === eraName) {\n                            return eras[i];\n                        }\n                        break;\n                    case \"NNNNN\":\n                        if (narrow === eraName) {\n                            return eras[i];\n                        }\n                        break;\n                }\n            } else if ([\n                name,\n                abbr,\n                narrow\n            ].indexOf(eraName) >= 0) {\n                return eras[i];\n            }\n        }\n    }\n    function localeErasConvertYear(era, year) {\n        var dir = era.since <= era.until ? +1 : -1;\n        if (year === undefined) {\n            return hooks(era.since).year();\n        } else {\n            return hooks(era.since).year() + (year - era.offset) * dir;\n        }\n    }\n    function getEraName() {\n        var i, l, val, eras = this.localeData().eras();\n        for(i = 0, l = eras.length; i < l; ++i){\n            // truncate time\n            val = this.clone().startOf(\"day\").valueOf();\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].name;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].name;\n            }\n        }\n        return \"\";\n    }\n    function getEraNarrow() {\n        var i, l, val, eras = this.localeData().eras();\n        for(i = 0, l = eras.length; i < l; ++i){\n            // truncate time\n            val = this.clone().startOf(\"day\").valueOf();\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].narrow;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].narrow;\n            }\n        }\n        return \"\";\n    }\n    function getEraAbbr() {\n        var i, l, val, eras = this.localeData().eras();\n        for(i = 0, l = eras.length; i < l; ++i){\n            // truncate time\n            val = this.clone().startOf(\"day\").valueOf();\n            if (eras[i].since <= val && val <= eras[i].until) {\n                return eras[i].abbr;\n            }\n            if (eras[i].until <= val && val <= eras[i].since) {\n                return eras[i].abbr;\n            }\n        }\n        return \"\";\n    }\n    function getEraYear() {\n        var i, l, dir, val, eras = this.localeData().eras();\n        for(i = 0, l = eras.length; i < l; ++i){\n            dir = eras[i].since <= eras[i].until ? +1 : -1;\n            // truncate time\n            val = this.clone().startOf(\"day\").valueOf();\n            if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {\n                return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;\n            }\n        }\n        return this.year();\n    }\n    function erasNameRegex(isStrict) {\n        if (!hasOwnProp(this, \"_erasNameRegex\")) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasNameRegex : this._erasRegex;\n    }\n    function erasAbbrRegex(isStrict) {\n        if (!hasOwnProp(this, \"_erasAbbrRegex\")) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasAbbrRegex : this._erasRegex;\n    }\n    function erasNarrowRegex(isStrict) {\n        if (!hasOwnProp(this, \"_erasNarrowRegex\")) {\n            computeErasParse.call(this);\n        }\n        return isStrict ? this._erasNarrowRegex : this._erasRegex;\n    }\n    function matchEraAbbr(isStrict, locale) {\n        return locale.erasAbbrRegex(isStrict);\n    }\n    function matchEraName(isStrict, locale) {\n        return locale.erasNameRegex(isStrict);\n    }\n    function matchEraNarrow(isStrict, locale) {\n        return locale.erasNarrowRegex(isStrict);\n    }\n    function matchEraYearOrdinal(isStrict, locale) {\n        return locale._eraYearOrdinalRegex || matchUnsigned;\n    }\n    function computeErasParse() {\n        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();\n        for(i = 0, l = eras.length; i < l; ++i){\n            namePieces.push(regexEscape(eras[i].name));\n            abbrPieces.push(regexEscape(eras[i].abbr));\n            narrowPieces.push(regexEscape(eras[i].narrow));\n            mixedPieces.push(regexEscape(eras[i].name));\n            mixedPieces.push(regexEscape(eras[i].abbr));\n            mixedPieces.push(regexEscape(eras[i].narrow));\n        }\n        this._erasRegex = new RegExp(\"^(\" + mixedPieces.join(\"|\") + \")\", \"i\");\n        this._erasNameRegex = new RegExp(\"^(\" + namePieces.join(\"|\") + \")\", \"i\");\n        this._erasAbbrRegex = new RegExp(\"^(\" + abbrPieces.join(\"|\") + \")\", \"i\");\n        this._erasNarrowRegex = new RegExp(\"^(\" + narrowPieces.join(\"|\") + \")\", \"i\");\n    }\n    // FORMATTING\n    addFormatToken(0, [\n        \"gg\",\n        2\n    ], 0, function() {\n        return this.weekYear() % 100;\n    });\n    addFormatToken(0, [\n        \"GG\",\n        2\n    ], 0, function() {\n        return this.isoWeekYear() % 100;\n    });\n    function addWeekYearFormatToken(token, getter) {\n        addFormatToken(0, [\n            token,\n            token.length\n        ], 0, getter);\n    }\n    addWeekYearFormatToken(\"gggg\", \"weekYear\");\n    addWeekYearFormatToken(\"ggggg\", \"weekYear\");\n    addWeekYearFormatToken(\"GGGG\", \"isoWeekYear\");\n    addWeekYearFormatToken(\"GGGGG\", \"isoWeekYear\");\n    // ALIASES\n    addUnitAlias(\"weekYear\", \"gg\");\n    addUnitAlias(\"isoWeekYear\", \"GG\");\n    // PRIORITY\n    addUnitPriority(\"weekYear\", 1);\n    addUnitPriority(\"isoWeekYear\", 1);\n    // PARSING\n    addRegexToken(\"G\", matchSigned);\n    addRegexToken(\"g\", matchSigned);\n    addRegexToken(\"GG\", match1to2, match2);\n    addRegexToken(\"gg\", match1to2, match2);\n    addRegexToken(\"GGGG\", match1to4, match4);\n    addRegexToken(\"gggg\", match1to4, match4);\n    addRegexToken(\"GGGGG\", match1to6, match6);\n    addRegexToken(\"ggggg\", match1to6, match6);\n    addWeekParseToken([\n        \"gggg\",\n        \"ggggg\",\n        \"GGGG\",\n        \"GGGGG\"\n    ], function(input, week, config, token) {\n        week[token.substr(0, 2)] = toInt(input);\n    });\n    addWeekParseToken([\n        \"gg\",\n        \"GG\"\n    ], function(input, week, config, token) {\n        week[token] = hooks.parseTwoDigitYear(input);\n    });\n    // MOMENTS\n    function getSetWeekYear(input) {\n        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);\n    }\n    function getSetISOWeekYear(input) {\n        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);\n    }\n    function getISOWeeksInYear() {\n        return weeksInYear(this.year(), 1, 4);\n    }\n    function getISOWeeksInISOWeekYear() {\n        return weeksInYear(this.isoWeekYear(), 1, 4);\n    }\n    function getWeeksInYear() {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);\n    }\n    function getWeeksInWeekYear() {\n        var weekInfo = this.localeData()._week;\n        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);\n    }\n    function getSetWeekYearHelper(input, week, weekday, dow, doy) {\n        var weeksTarget;\n        if (input == null) {\n            return weekOfYear(this, dow, doy).year;\n        } else {\n            weeksTarget = weeksInYear(input, dow, doy);\n            if (week > weeksTarget) {\n                week = weeksTarget;\n            }\n            return setWeekAll.call(this, input, week, weekday, dow, doy);\n        }\n    }\n    function setWeekAll(weekYear, week, weekday, dow, doy) {\n        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);\n        this.year(date.getUTCFullYear());\n        this.month(date.getUTCMonth());\n        this.date(date.getUTCDate());\n        return this;\n    }\n    // FORMATTING\n    addFormatToken(\"Q\", 0, \"Qo\", \"quarter\");\n    // ALIASES\n    addUnitAlias(\"quarter\", \"Q\");\n    // PRIORITY\n    addUnitPriority(\"quarter\", 7);\n    // PARSING\n    addRegexToken(\"Q\", match1);\n    addParseToken(\"Q\", function(input, array) {\n        array[MONTH] = (toInt(input) - 1) * 3;\n    });\n    // MOMENTS\n    function getSetQuarter(input) {\n        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);\n    }\n    // FORMATTING\n    addFormatToken(\"D\", [\n        \"DD\",\n        2\n    ], \"Do\", \"date\");\n    // ALIASES\n    addUnitAlias(\"date\", \"D\");\n    // PRIORITY\n    addUnitPriority(\"date\", 9);\n    // PARSING\n    addRegexToken(\"D\", match1to2);\n    addRegexToken(\"DD\", match1to2, match2);\n    addRegexToken(\"Do\", function(isStrict, locale) {\n        // TODO: Remove \"ordinalParse\" fallback in next major release.\n        return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;\n    });\n    addParseToken([\n        \"D\",\n        \"DD\"\n    ], DATE);\n    addParseToken(\"Do\", function(input, array) {\n        array[DATE] = toInt(input.match(match1to2)[0]);\n    });\n    // MOMENTS\n    var getSetDayOfMonth = makeGetSet(\"Date\", true);\n    // FORMATTING\n    addFormatToken(\"DDD\", [\n        \"DDDD\",\n        3\n    ], \"DDDo\", \"dayOfYear\");\n    // ALIASES\n    addUnitAlias(\"dayOfYear\", \"DDD\");\n    // PRIORITY\n    addUnitPriority(\"dayOfYear\", 4);\n    // PARSING\n    addRegexToken(\"DDD\", match1to3);\n    addRegexToken(\"DDDD\", match3);\n    addParseToken([\n        \"DDD\",\n        \"DDDD\"\n    ], function(input, array, config) {\n        config._dayOfYear = toInt(input);\n    });\n    // HELPERS\n    // MOMENTS\n    function getSetDayOfYear(input) {\n        var dayOfYear = Math.round((this.clone().startOf(\"day\") - this.clone().startOf(\"year\")) / 864e5) + 1;\n        return input == null ? dayOfYear : this.add(input - dayOfYear, \"d\");\n    }\n    // FORMATTING\n    addFormatToken(\"m\", [\n        \"mm\",\n        2\n    ], 0, \"minute\");\n    // ALIASES\n    addUnitAlias(\"minute\", \"m\");\n    // PRIORITY\n    addUnitPriority(\"minute\", 14);\n    // PARSING\n    addRegexToken(\"m\", match1to2);\n    addRegexToken(\"mm\", match1to2, match2);\n    addParseToken([\n        \"m\",\n        \"mm\"\n    ], MINUTE);\n    // MOMENTS\n    var getSetMinute = makeGetSet(\"Minutes\", false);\n    // FORMATTING\n    addFormatToken(\"s\", [\n        \"ss\",\n        2\n    ], 0, \"second\");\n    // ALIASES\n    addUnitAlias(\"second\", \"s\");\n    // PRIORITY\n    addUnitPriority(\"second\", 15);\n    // PARSING\n    addRegexToken(\"s\", match1to2);\n    addRegexToken(\"ss\", match1to2, match2);\n    addParseToken([\n        \"s\",\n        \"ss\"\n    ], SECOND);\n    // MOMENTS\n    var getSetSecond = makeGetSet(\"Seconds\", false);\n    // FORMATTING\n    addFormatToken(\"S\", 0, 0, function() {\n        return ~~(this.millisecond() / 100);\n    });\n    addFormatToken(0, [\n        \"SS\",\n        2\n    ], 0, function() {\n        return ~~(this.millisecond() / 10);\n    });\n    addFormatToken(0, [\n        \"SSS\",\n        3\n    ], 0, \"millisecond\");\n    addFormatToken(0, [\n        \"SSSS\",\n        4\n    ], 0, function() {\n        return this.millisecond() * 10;\n    });\n    addFormatToken(0, [\n        \"SSSSS\",\n        5\n    ], 0, function() {\n        return this.millisecond() * 100;\n    });\n    addFormatToken(0, [\n        \"SSSSSS\",\n        6\n    ], 0, function() {\n        return this.millisecond() * 1000;\n    });\n    addFormatToken(0, [\n        \"SSSSSSS\",\n        7\n    ], 0, function() {\n        return this.millisecond() * 10000;\n    });\n    addFormatToken(0, [\n        \"SSSSSSSS\",\n        8\n    ], 0, function() {\n        return this.millisecond() * 100000;\n    });\n    addFormatToken(0, [\n        \"SSSSSSSSS\",\n        9\n    ], 0, function() {\n        return this.millisecond() * 1000000;\n    });\n    // ALIASES\n    addUnitAlias(\"millisecond\", \"ms\");\n    // PRIORITY\n    addUnitPriority(\"millisecond\", 16);\n    // PARSING\n    addRegexToken(\"S\", match1to3, match1);\n    addRegexToken(\"SS\", match1to3, match2);\n    addRegexToken(\"SSS\", match1to3, match3);\n    var token, getSetMillisecond;\n    for(token = \"SSSS\"; token.length <= 9; token += \"S\"){\n        addRegexToken(token, matchUnsigned);\n    }\n    function parseMs(input, array) {\n        array[MILLISECOND] = toInt((\"0.\" + input) * 1000);\n    }\n    for(token = \"S\"; token.length <= 9; token += \"S\"){\n        addParseToken(token, parseMs);\n    }\n    getSetMillisecond = makeGetSet(\"Milliseconds\", false);\n    // FORMATTING\n    addFormatToken(\"z\", 0, 0, \"zoneAbbr\");\n    addFormatToken(\"zz\", 0, 0, \"zoneName\");\n    // MOMENTS\n    function getZoneAbbr() {\n        return this._isUTC ? \"UTC\" : \"\";\n    }\n    function getZoneName() {\n        return this._isUTC ? \"Coordinated Universal Time\" : \"\";\n    }\n    var proto = Moment.prototype;\n    proto.add = add;\n    proto.calendar = calendar$1;\n    proto.clone = clone;\n    proto.diff = diff;\n    proto.endOf = endOf;\n    proto.format = format;\n    proto.from = from;\n    proto.fromNow = fromNow;\n    proto.to = to;\n    proto.toNow = toNow;\n    proto.get = stringGet;\n    proto.invalidAt = invalidAt;\n    proto.isAfter = isAfter;\n    proto.isBefore = isBefore;\n    proto.isBetween = isBetween;\n    proto.isSame = isSame;\n    proto.isSameOrAfter = isSameOrAfter;\n    proto.isSameOrBefore = isSameOrBefore;\n    proto.isValid = isValid$2;\n    proto.lang = lang;\n    proto.locale = locale;\n    proto.localeData = localeData;\n    proto.max = prototypeMax;\n    proto.min = prototypeMin;\n    proto.parsingFlags = parsingFlags;\n    proto.set = stringSet;\n    proto.startOf = startOf;\n    proto.subtract = subtract;\n    proto.toArray = toArray;\n    proto.toObject = toObject;\n    proto.toDate = toDate;\n    proto.toISOString = toISOString;\n    proto.inspect = inspect;\n    if (typeof Symbol !== \"undefined\" && Symbol.for != null) {\n        proto[Symbol.for(\"nodejs.util.inspect.custom\")] = function() {\n            return \"Moment<\" + this.format() + \">\";\n        };\n    }\n    proto.toJSON = toJSON;\n    proto.toString = toString;\n    proto.unix = unix;\n    proto.valueOf = valueOf;\n    proto.creationData = creationData;\n    proto.eraName = getEraName;\n    proto.eraNarrow = getEraNarrow;\n    proto.eraAbbr = getEraAbbr;\n    proto.eraYear = getEraYear;\n    proto.year = getSetYear;\n    proto.isLeapYear = getIsLeapYear;\n    proto.weekYear = getSetWeekYear;\n    proto.isoWeekYear = getSetISOWeekYear;\n    proto.quarter = proto.quarters = getSetQuarter;\n    proto.month = getSetMonth;\n    proto.daysInMonth = getDaysInMonth;\n    proto.week = proto.weeks = getSetWeek;\n    proto.isoWeek = proto.isoWeeks = getSetISOWeek;\n    proto.weeksInYear = getWeeksInYear;\n    proto.weeksInWeekYear = getWeeksInWeekYear;\n    proto.isoWeeksInYear = getISOWeeksInYear;\n    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;\n    proto.date = getSetDayOfMonth;\n    proto.day = proto.days = getSetDayOfWeek;\n    proto.weekday = getSetLocaleDayOfWeek;\n    proto.isoWeekday = getSetISODayOfWeek;\n    proto.dayOfYear = getSetDayOfYear;\n    proto.hour = proto.hours = getSetHour;\n    proto.minute = proto.minutes = getSetMinute;\n    proto.second = proto.seconds = getSetSecond;\n    proto.millisecond = proto.milliseconds = getSetMillisecond;\n    proto.utcOffset = getSetOffset;\n    proto.utc = setOffsetToUTC;\n    proto.local = setOffsetToLocal;\n    proto.parseZone = setOffsetToParsedOffset;\n    proto.hasAlignedHourOffset = hasAlignedHourOffset;\n    proto.isDST = isDaylightSavingTime;\n    proto.isLocal = isLocal;\n    proto.isUtcOffset = isUtcOffset;\n    proto.isUtc = isUtc;\n    proto.isUTC = isUtc;\n    proto.zoneAbbr = getZoneAbbr;\n    proto.zoneName = getZoneName;\n    proto.dates = deprecate(\"dates accessor is deprecated. Use date instead.\", getSetDayOfMonth);\n    proto.months = deprecate(\"months accessor is deprecated. Use month instead\", getSetMonth);\n    proto.years = deprecate(\"years accessor is deprecated. Use year instead\", getSetYear);\n    proto.zone = deprecate(\"moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/\", getSetZone);\n    proto.isDSTShifted = deprecate(\"isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information\", isDaylightSavingTimeShifted);\n    function createUnix(input) {\n        return createLocal(input * 1000);\n    }\n    function createInZone() {\n        return createLocal.apply(null, arguments).parseZone();\n    }\n    function preParsePostFormat(string) {\n        return string;\n    }\n    var proto$1 = Locale.prototype;\n    proto$1.calendar = calendar;\n    proto$1.longDateFormat = longDateFormat;\n    proto$1.invalidDate = invalidDate;\n    proto$1.ordinal = ordinal;\n    proto$1.preparse = preParsePostFormat;\n    proto$1.postformat = preParsePostFormat;\n    proto$1.relativeTime = relativeTime;\n    proto$1.pastFuture = pastFuture;\n    proto$1.set = set;\n    proto$1.eras = localeEras;\n    proto$1.erasParse = localeErasParse;\n    proto$1.erasConvertYear = localeErasConvertYear;\n    proto$1.erasAbbrRegex = erasAbbrRegex;\n    proto$1.erasNameRegex = erasNameRegex;\n    proto$1.erasNarrowRegex = erasNarrowRegex;\n    proto$1.months = localeMonths;\n    proto$1.monthsShort = localeMonthsShort;\n    proto$1.monthsParse = localeMonthsParse;\n    proto$1.monthsRegex = monthsRegex;\n    proto$1.monthsShortRegex = monthsShortRegex;\n    proto$1.week = localeWeek;\n    proto$1.firstDayOfYear = localeFirstDayOfYear;\n    proto$1.firstDayOfWeek = localeFirstDayOfWeek;\n    proto$1.weekdays = localeWeekdays;\n    proto$1.weekdaysMin = localeWeekdaysMin;\n    proto$1.weekdaysShort = localeWeekdaysShort;\n    proto$1.weekdaysParse = localeWeekdaysParse;\n    proto$1.weekdaysRegex = weekdaysRegex;\n    proto$1.weekdaysShortRegex = weekdaysShortRegex;\n    proto$1.weekdaysMinRegex = weekdaysMinRegex;\n    proto$1.isPM = localeIsPM;\n    proto$1.meridiem = localeMeridiem;\n    function get$1(format, index, field, setter) {\n        var locale = getLocale(), utc = createUTC().set(setter, index);\n        return locale[field](utc, format);\n    }\n    function listMonthsImpl(format, index, field) {\n        if (isNumber(format)) {\n            index = format;\n            format = undefined;\n        }\n        format = format || \"\";\n        if (index != null) {\n            return get$1(format, index, field, \"month\");\n        }\n        var i, out = [];\n        for(i = 0; i < 12; i++){\n            out[i] = get$1(format, i, field, \"month\");\n        }\n        return out;\n    }\n    // ()\n    // (5)\n    // (fmt, 5)\n    // (fmt)\n    // (true)\n    // (true, 5)\n    // (true, fmt, 5)\n    // (true, fmt)\n    function listWeekdaysImpl(localeSorted, format, index, field) {\n        if (typeof localeSorted === \"boolean\") {\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n            format = format || \"\";\n        } else {\n            format = localeSorted;\n            index = format;\n            localeSorted = false;\n            if (isNumber(format)) {\n                index = format;\n                format = undefined;\n            }\n            format = format || \"\";\n        }\n        var locale = getLocale(), shift = localeSorted ? locale._week.dow : 0, i, out = [];\n        if (index != null) {\n            return get$1(format, (index + shift) % 7, field, \"day\");\n        }\n        for(i = 0; i < 7; i++){\n            out[i] = get$1(format, (i + shift) % 7, field, \"day\");\n        }\n        return out;\n    }\n    function listMonths(format, index) {\n        return listMonthsImpl(format, index, \"months\");\n    }\n    function listMonthsShort(format, index) {\n        return listMonthsImpl(format, index, \"monthsShort\");\n    }\n    function listWeekdays(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, \"weekdays\");\n    }\n    function listWeekdaysShort(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, \"weekdaysShort\");\n    }\n    function listWeekdaysMin(localeSorted, format, index) {\n        return listWeekdaysImpl(localeSorted, format, index, \"weekdaysMin\");\n    }\n    getSetGlobalLocale(\"en\", {\n        eras: [\n            {\n                since: \"0001-01-01\",\n                until: +Infinity,\n                offset: 1,\n                name: \"Anno Domini\",\n                narrow: \"AD\",\n                abbr: \"AD\"\n            },\n            {\n                since: \"0000-12-31\",\n                until: -Infinity,\n                offset: 1,\n                name: \"Before Christ\",\n                narrow: \"BC\",\n                abbr: \"BC\"\n            }\n        ],\n        dayOfMonthOrdinalParse: /\\d{1,2}(th|st|nd|rd)/,\n        ordinal: function(number) {\n            var b = number % 10, output = toInt(number % 100 / 10) === 1 ? \"th\" : b === 1 ? \"st\" : b === 2 ? \"nd\" : b === 3 ? \"rd\" : \"th\";\n            return number + output;\n        }\n    });\n    // Side effect imports\n    hooks.lang = deprecate(\"moment.lang is deprecated. Use moment.locale instead.\", getSetGlobalLocale);\n    hooks.langData = deprecate(\"moment.langData is deprecated. Use moment.localeData instead.\", getLocale);\n    var mathAbs = Math.abs;\n    function abs() {\n        var data = this._data;\n        this._milliseconds = mathAbs(this._milliseconds);\n        this._days = mathAbs(this._days);\n        this._months = mathAbs(this._months);\n        data.milliseconds = mathAbs(data.milliseconds);\n        data.seconds = mathAbs(data.seconds);\n        data.minutes = mathAbs(data.minutes);\n        data.hours = mathAbs(data.hours);\n        data.months = mathAbs(data.months);\n        data.years = mathAbs(data.years);\n        return this;\n    }\n    function addSubtract$1(duration, input, value, direction) {\n        var other = createDuration(input, value);\n        duration._milliseconds += direction * other._milliseconds;\n        duration._days += direction * other._days;\n        duration._months += direction * other._months;\n        return duration._bubble();\n    }\n    // supports only 2.0-style add(1, 's') or add(duration)\n    function add$1(input, value) {\n        return addSubtract$1(this, input, value, 1);\n    }\n    // supports only 2.0-style subtract(1, 's') or subtract(duration)\n    function subtract$1(input, value) {\n        return addSubtract$1(this, input, value, -1);\n    }\n    function absCeil(number) {\n        if (number < 0) {\n            return Math.floor(number);\n        } else {\n            return Math.ceil(number);\n        }\n    }\n    function bubble() {\n        var milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, seconds, minutes, hours, years, monthsFromDays;\n        // if we have a mix of positive and negative values, bubble down first\n        // check: https://github.com/moment/moment/issues/2166\n        if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {\n            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;\n            days = 0;\n            months = 0;\n        }\n        // The following code bubbles up values, see the tests for\n        // examples of what that means.\n        data.milliseconds = milliseconds % 1000;\n        seconds = absFloor(milliseconds / 1000);\n        data.seconds = seconds % 60;\n        minutes = absFloor(seconds / 60);\n        data.minutes = minutes % 60;\n        hours = absFloor(minutes / 60);\n        data.hours = hours % 24;\n        days += absFloor(hours / 24);\n        // convert days to months\n        monthsFromDays = absFloor(daysToMonths(days));\n        months += monthsFromDays;\n        days -= absCeil(monthsToDays(monthsFromDays));\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n        data.days = days;\n        data.months = months;\n        data.years = years;\n        return this;\n    }\n    function daysToMonths(days) {\n        // 400 years have 146097 days (taking into account leap year rules)\n        // 400 years have 12 months === 4800\n        return days * 4800 / 146097;\n    }\n    function monthsToDays(months) {\n        // the reverse of daysToMonths\n        return months * 146097 / 4800;\n    }\n    function as(units) {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        var days, months, milliseconds = this._milliseconds;\n        units = normalizeUnits(units);\n        if (units === \"month\" || units === \"quarter\" || units === \"year\") {\n            days = this._days + milliseconds / 864e5;\n            months = this._months + daysToMonths(days);\n            switch(units){\n                case \"month\":\n                    return months;\n                case \"quarter\":\n                    return months / 3;\n                case \"year\":\n                    return months / 12;\n            }\n        } else {\n            // handle milliseconds separately because of floating point math errors (issue #1867)\n            days = this._days + Math.round(monthsToDays(this._months));\n            switch(units){\n                case \"week\":\n                    return days / 7 + milliseconds / 6048e5;\n                case \"day\":\n                    return days + milliseconds / 864e5;\n                case \"hour\":\n                    return days * 24 + milliseconds / 36e5;\n                case \"minute\":\n                    return days * 1440 + milliseconds / 6e4;\n                case \"second\":\n                    return days * 86400 + milliseconds / 1000;\n                // Math.floor prevents floating point math errors here\n                case \"millisecond\":\n                    return Math.floor(days * 864e5) + milliseconds;\n                default:\n                    throw new Error(\"Unknown unit \" + units);\n            }\n        }\n    }\n    // TODO: Use this.as('ms')?\n    function valueOf$1() {\n        if (!this.isValid()) {\n            return NaN;\n        }\n        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;\n    }\n    function makeAs(alias) {\n        return function() {\n            return this.as(alias);\n        };\n    }\n    var asMilliseconds = makeAs(\"ms\"), asSeconds = makeAs(\"s\"), asMinutes = makeAs(\"m\"), asHours = makeAs(\"h\"), asDays = makeAs(\"d\"), asWeeks = makeAs(\"w\"), asMonths = makeAs(\"M\"), asQuarters = makeAs(\"Q\"), asYears = makeAs(\"y\");\n    function clone$1() {\n        return createDuration(this);\n    }\n    function get$2(units) {\n        units = normalizeUnits(units);\n        return this.isValid() ? this[units + \"s\"]() : NaN;\n    }\n    function makeGetter(name) {\n        return function() {\n            return this.isValid() ? this._data[name] : NaN;\n        };\n    }\n    var milliseconds = makeGetter(\"milliseconds\"), seconds = makeGetter(\"seconds\"), minutes = makeGetter(\"minutes\"), hours = makeGetter(\"hours\"), days = makeGetter(\"days\"), months = makeGetter(\"months\"), years = makeGetter(\"years\");\n    function weeks() {\n        return absFloor(this.days() / 7);\n    }\n    var round = Math.round, thresholds = {\n        ss: 44,\n        s: 45,\n        m: 45,\n        h: 22,\n        d: 26,\n        w: null,\n        M: 11\n    };\n    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize\n    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {\n        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);\n    }\n    function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {\n        var duration = createDuration(posNegDuration).abs(), seconds = round(duration.as(\"s\")), minutes = round(duration.as(\"m\")), hours = round(duration.as(\"h\")), days = round(duration.as(\"d\")), months = round(duration.as(\"M\")), weeks = round(duration.as(\"w\")), years = round(duration.as(\"y\")), a = seconds <= thresholds.ss && [\n            \"s\",\n            seconds\n        ] || seconds < thresholds.s && [\n            \"ss\",\n            seconds\n        ] || minutes <= 1 && [\n            \"m\"\n        ] || minutes < thresholds.m && [\n            \"mm\",\n            minutes\n        ] || hours <= 1 && [\n            \"h\"\n        ] || hours < thresholds.h && [\n            \"hh\",\n            hours\n        ] || days <= 1 && [\n            \"d\"\n        ] || days < thresholds.d && [\n            \"dd\",\n            days\n        ];\n        if (thresholds.w != null) {\n            a = a || weeks <= 1 && [\n                \"w\"\n            ] || weeks < thresholds.w && [\n                \"ww\",\n                weeks\n            ];\n        }\n        a = a || months <= 1 && [\n            \"M\"\n        ] || months < thresholds.M && [\n            \"MM\",\n            months\n        ] || years <= 1 && [\n            \"y\"\n        ] || [\n            \"yy\",\n            years\n        ];\n        a[2] = withoutSuffix;\n        a[3] = +posNegDuration > 0;\n        a[4] = locale;\n        return substituteTimeAgo.apply(null, a);\n    }\n    // This function allows you to set the rounding function for relative time strings\n    function getSetRelativeTimeRounding(roundingFunction) {\n        if (roundingFunction === undefined) {\n            return round;\n        }\n        if (typeof roundingFunction === \"function\") {\n            round = roundingFunction;\n            return true;\n        }\n        return false;\n    }\n    // This function allows you to set a threshold for relative time strings\n    function getSetRelativeTimeThreshold(threshold, limit) {\n        if (thresholds[threshold] === undefined) {\n            return false;\n        }\n        if (limit === undefined) {\n            return thresholds[threshold];\n        }\n        thresholds[threshold] = limit;\n        if (threshold === \"s\") {\n            thresholds.ss = limit - 1;\n        }\n        return true;\n    }\n    function humanize(argWithSuffix, argThresholds) {\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n        var withSuffix = false, th = thresholds, locale, output;\n        if (typeof argWithSuffix === \"object\") {\n            argThresholds = argWithSuffix;\n            argWithSuffix = false;\n        }\n        if (typeof argWithSuffix === \"boolean\") {\n            withSuffix = argWithSuffix;\n        }\n        if (typeof argThresholds === \"object\") {\n            th = Object.assign({}, thresholds, argThresholds);\n            if (argThresholds.s != null && argThresholds.ss == null) {\n                th.ss = argThresholds.s - 1;\n            }\n        }\n        locale = this.localeData();\n        output = relativeTime$1(this, !withSuffix, th, locale);\n        if (withSuffix) {\n            output = locale.pastFuture(+this, output);\n        }\n        return locale.postformat(output);\n    }\n    var abs$1 = Math.abs;\n    function sign(x) {\n        return (x > 0) - (x < 0) || +x;\n    }\n    function toISOString$1() {\n        // for ISO strings we do not use the normal bubbling rules:\n        //  * milliseconds bubble up until they become hours\n        //  * days do not bubble at all\n        //  * months bubble up until they become years\n        // This is because there is no context-free conversion between hours and days\n        // (think of clock changes)\n        // and also not between days and months (28-31 days per month)\n        if (!this.isValid()) {\n            return this.localeData().invalidDate();\n        }\n        var seconds = abs$1(this._milliseconds) / 1000, days = abs$1(this._days), months = abs$1(this._months), minutes, hours, years, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;\n        if (!total) {\n            // this is the same as C#'s (Noda) and python (isodate)...\n            // but not other JS (goog.date)\n            return \"P0D\";\n        }\n        // 3600 seconds -> 60 minutes -> 1 hour\n        minutes = absFloor(seconds / 60);\n        hours = absFloor(minutes / 60);\n        seconds %= 60;\n        minutes %= 60;\n        // 12 months -> 1 year\n        years = absFloor(months / 12);\n        months %= 12;\n        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js\n        s = seconds ? seconds.toFixed(3).replace(/\\.?0+$/, \"\") : \"\";\n        totalSign = total < 0 ? \"-\" : \"\";\n        ymSign = sign(this._months) !== sign(total) ? \"-\" : \"\";\n        daysSign = sign(this._days) !== sign(total) ? \"-\" : \"\";\n        hmsSign = sign(this._milliseconds) !== sign(total) ? \"-\" : \"\";\n        return totalSign + \"P\" + (years ? ymSign + years + \"Y\" : \"\") + (months ? ymSign + months + \"M\" : \"\") + (days ? daysSign + days + \"D\" : \"\") + (hours || minutes || seconds ? \"T\" : \"\") + (hours ? hmsSign + hours + \"H\" : \"\") + (minutes ? hmsSign + minutes + \"M\" : \"\") + (seconds ? hmsSign + s + \"S\" : \"\");\n    }\n    var proto$2 = Duration.prototype;\n    proto$2.isValid = isValid$1;\n    proto$2.abs = abs;\n    proto$2.add = add$1;\n    proto$2.subtract = subtract$1;\n    proto$2.as = as;\n    proto$2.asMilliseconds = asMilliseconds;\n    proto$2.asSeconds = asSeconds;\n    proto$2.asMinutes = asMinutes;\n    proto$2.asHours = asHours;\n    proto$2.asDays = asDays;\n    proto$2.asWeeks = asWeeks;\n    proto$2.asMonths = asMonths;\n    proto$2.asQuarters = asQuarters;\n    proto$2.asYears = asYears;\n    proto$2.valueOf = valueOf$1;\n    proto$2._bubble = bubble;\n    proto$2.clone = clone$1;\n    proto$2.get = get$2;\n    proto$2.milliseconds = milliseconds;\n    proto$2.seconds = seconds;\n    proto$2.minutes = minutes;\n    proto$2.hours = hours;\n    proto$2.days = days;\n    proto$2.weeks = weeks;\n    proto$2.months = months;\n    proto$2.years = years;\n    proto$2.humanize = humanize;\n    proto$2.toISOString = toISOString$1;\n    proto$2.toString = toISOString$1;\n    proto$2.toJSON = toISOString$1;\n    proto$2.locale = locale;\n    proto$2.localeData = localeData;\n    proto$2.toIsoString = deprecate(\"toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)\", toISOString$1);\n    proto$2.lang = lang;\n    // FORMATTING\n    addFormatToken(\"X\", 0, 0, \"unix\");\n    addFormatToken(\"x\", 0, 0, \"valueOf\");\n    // PARSING\n    addRegexToken(\"x\", matchSigned);\n    addRegexToken(\"X\", matchTimestamp);\n    addParseToken(\"X\", function(input, array, config) {\n        config._d = new Date(parseFloat(input) * 1000);\n    });\n    addParseToken(\"x\", function(input, array, config) {\n        config._d = new Date(toInt(input));\n    });\n    //! moment.js\n    hooks.version = \"2.29.4\";\n    setHookCallback(createLocal);\n    hooks.fn = proto;\n    hooks.min = min;\n    hooks.max = max;\n    hooks.now = now;\n    hooks.utc = createUTC;\n    hooks.unix = createUnix;\n    hooks.months = listMonths;\n    hooks.isDate = isDate;\n    hooks.locale = getSetGlobalLocale;\n    hooks.invalid = createInvalid;\n    hooks.duration = createDuration;\n    hooks.isMoment = isMoment;\n    hooks.weekdays = listWeekdays;\n    hooks.parseZone = createInZone;\n    hooks.localeData = getLocale;\n    hooks.isDuration = isDuration;\n    hooks.monthsShort = listMonthsShort;\n    hooks.weekdaysMin = listWeekdaysMin;\n    hooks.defineLocale = defineLocale;\n    hooks.updateLocale = updateLocale;\n    hooks.locales = listLocales;\n    hooks.weekdaysShort = listWeekdaysShort;\n    hooks.normalizeUnits = normalizeUnits;\n    hooks.relativeTimeRounding = getSetRelativeTimeRounding;\n    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;\n    hooks.calendarFormat = getCalendarFormat;\n    hooks.prototype = proto;\n    // currently HTML5 input type only supports 24-hour formats\n    hooks.HTML5_FMT = {\n        DATETIME_LOCAL: \"YYYY-MM-DDTHH:mm\",\n        DATETIME_LOCAL_SECONDS: \"YYYY-MM-DDTHH:mm:ss\",\n        DATETIME_LOCAL_MS: \"YYYY-MM-DDTHH:mm:ss.SSS\",\n        DATE: \"YYYY-MM-DD\",\n        TIME: \"HH:mm\",\n        TIME_SECONDS: \"HH:mm:ss\",\n        TIME_MS: \"HH:mm:ss.SSS\",\n        WEEK: \"GGGG-[W]WW\",\n        MONTH: \"YYYY-MM\"\n    };\n    return hooks;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TUFBTWcwQixTQUFTLEdBQUdPO0lBQ2xCdjBCLE1BQU1xSyxVQUFVLEdBQUc2VDtJQUNuQmxlLE1BQU1tbkIsVUFBVSxHQUFHQTtJQUNuQm5uQixNQUFNcVQsV0FBVyxHQUFHaWlCO0lBQ3BCdDFCLE1BQU1vWSxXQUFXLEdBQUdxZDtJQUNwQnoxQixNQUFNbWUsWUFBWSxHQUFHQTtJQUNyQm5lLE1BQU11ZSxZQUFZLEdBQUdBO0lBQ3JCdmUsTUFBTTRjLE9BQU8sR0FBRzZCO0lBQ2hCemUsTUFBTXFZLGFBQWEsR0FBR21kO0lBQ3RCeDFCLE1BQU0rTixjQUFjLEdBQUdBO0lBQ3ZCL04sTUFBTTY0QixvQkFBb0IsR0FBR3JCO0lBQzdCeDNCLE1BQU04NEIscUJBQXFCLEdBQUdwQjtJQUM5QjEzQixNQUFNd3NCLGNBQWMsR0FBR1A7SUFDdkJqc0IsTUFBTVMsU0FBUyxHQUFHNnlCO0lBRWxCLDJEQUEyRDtJQUMzRHR6QixNQUFNKzRCLFNBQVMsR0FBRztRQUNkQyxnQkFBZ0I7UUFDaEJDLHdCQUF3QjtRQUN4QkMsbUJBQW1CO1FBQ25CMW1CLE1BQU07UUFDTjJtQixNQUFNO1FBQ05DLGNBQWM7UUFDZEMsU0FBUztRQUNUeG1CLE1BQU07UUFDTk4sT0FBTztJQUNYO0lBRUEsT0FBT3ZTO0FBRVgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZXZlbG9wZXItZGFpcnkvLi9ub2RlX21vZHVsZXMvbW9tZW50L21vbWVudC5qcz85MzgwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4yOS40XG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gaG9va3MoKSB7XG4gICAgICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuICAgIC8vIHdpdGhvdXQgY3JlYXRpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuICAgIGZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlucHV0ICE9IG51bGwgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PT0gdm9pZCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgYXJyTGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyckxlbjsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHk6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0OiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93OiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXI6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQ6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZEVyYTogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRNb250aDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQ6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbzogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZWREYXRlUGFydHM6IFtdLFxuICAgICAgICAgICAgZXJhOiBudWxsLFxuICAgICAgICAgICAgbWVyaWRpZW06IG51bGwsXG4gICAgICAgICAgICByZmMyODIyOiBmYWxzZSxcbiAgICAgICAgICAgIHdlZWtkYXlNaXNtYXRjaDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICB2YXIgc29tZTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICBsZW4gPSB0Lmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXMsIHRbaV0sIGksIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSksXG4gICAgICAgICAgICAgICAgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPVxuICAgICAgICAgICAgICAgICAgICAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRFcmEgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPVxuICAgICAgICAgICAgICAgICAgICBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSAoaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdKSxcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBtb21lbnRQcm9wZXJ0aWVzTGVuID0gbW9tZW50UHJvcGVydGllcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzTGVuID4gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXNMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnQob2JqKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgYXJnTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJnTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3AoYXJndW1lbnRzWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgbXNnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXG5Bcmd1bWVudHM6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKCkuc3RhY2tcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbiAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHR5cGVvZiBGdW5jdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBwcm9wLCBpO1xuICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjb25maWcsIGkpKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICd8JyArXG4gICAgICAgICAgICAgICAgL1xcZHsxLDJ9Ly5zb3VyY2VcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLFxuICAgICAgICAgICAgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgIHNhbWVEYXk6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheTogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgIGxhc3REYXk6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlOiAnTCcsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV0gfHwgdGhpcy5fY2FsZW5kYXJbJ3NhbWVFbHNlJ107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArXG4gICAgICAgICAgICBhYnNOdW1iZXJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9XG4gICAgICAgICAgICAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fE57MSw1fXxZWVlZWVl8WVlZWVl8WVlZWXxZWXx5ezIsNH18eW8/fGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nLFxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nLFxuICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB7fSxcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbih0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLFxuICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gaXNGdW5jdGlvbihhcnJheVtpXSlcbiAgICAgICAgICAgICAgICAgICAgPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9XG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vuc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFM6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVDogJ2g6bW0gQScsXG4gICAgICAgIEw6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEw6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEw6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgTExMTDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlclxuICAgICAgICAgICAgLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0b2spIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NTU0nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NJyB8fFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdERCcgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnZGRkZCdcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvay5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnLFxuICAgICAgICBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsKG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgIGZ1dHVyZTogJ2luICVzJyxcbiAgICAgICAgcGFzdDogJyVzIGFnbycsXG4gICAgICAgIHM6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgc3M6ICclZCBzZWNvbmRzJyxcbiAgICAgICAgbTogJ2EgbWludXRlJyxcbiAgICAgICAgbW06ICclZCBtaW51dGVzJyxcbiAgICAgICAgaDogJ2FuIGhvdXInLFxuICAgICAgICBoaDogJyVkIGhvdXJzJyxcbiAgICAgICAgZDogJ2EgZGF5JyxcbiAgICAgICAgZGQ6ICclZCBkYXlzJyxcbiAgICAgICAgdzogJ2Egd2VlaycsXG4gICAgICAgIHd3OiAnJWQgd2Vla3MnLFxuICAgICAgICBNOiAnYSBtb250aCcsXG4gICAgICAgIE1NOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeTogJ2EgeWVhcicsXG4gICAgICAgIHl5OiAnJWQgeWVhcnMnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KVxuICAgICAgICAgICAgPyBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKVxuICAgICAgICAgICAgOiBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzKHVuaXQsIHNob3J0aGFuZCkge1xuICAgICAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIHZhciBwcmlvcml0aWVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICAgICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICAgICAgdmFyIHVuaXRzID0gW10sXG4gICAgICAgICAgICB1O1xuICAgICAgICBmb3IgKHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKHVuaXRzT2JqLCB1KSkge1xuICAgICAgICAgICAgICAgIHVuaXRzLnB1c2goeyB1bml0OiB1LCBwcmlvcml0eTogcHJpb3JpdGllc1t1XSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNGbG9vcihudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0U2V0KHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0KG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKVxuICAgICAgICAgICAgPyBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKVxuICAgICAgICAgICAgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0JDEobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJlxuICAgICAgICAgICAgICAgIGlzTGVhcFllYXIobW9tLnllYXIoKSkgJiZcbiAgICAgICAgICAgICAgICBtb20ubW9udGgoKSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIG1vbS5kYXRlKCkgPT09IDI5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBtb20ubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdHZXQodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5nU2V0KHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHByaW9yaXRpemVkTGVuID0gcHJpb3JpdGl6ZWQubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHByaW9yaXRpemVkTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2gxID0gL1xcZC8sIC8vICAgICAgIDAgLSA5XG4gICAgICAgIG1hdGNoMiA9IC9cXGRcXGQvLCAvLyAgICAgIDAwIC0gOTlcbiAgICAgICAgbWF0Y2gzID0gL1xcZHszfS8sIC8vICAgICAwMDAgLSA5OTlcbiAgICAgICAgbWF0Y2g0ID0gL1xcZHs0fS8sIC8vICAgIDAwMDAgLSA5OTk5XG4gICAgICAgIG1hdGNoNiA9IC9bKy1dP1xcZHs2fS8sIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICAgICAgbWF0Y2gxdG8yID0gL1xcZFxcZD8vLCAvLyAgICAgICAwIC0gOTlcbiAgICAgICAgbWF0Y2gzdG80ID0gL1xcZFxcZFxcZFxcZD8vLCAvLyAgICAgOTk5IC0gOTk5OVxuICAgICAgICBtYXRjaDV0bzYgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy8sIC8vICAgOTk5OTkgLSA5OTk5OTlcbiAgICAgICAgbWF0Y2gxdG8zID0gL1xcZHsxLDN9LywgLy8gICAgICAgMCAtIDk5OVxuICAgICAgICBtYXRjaDF0bzQgPSAvXFxkezEsNH0vLCAvLyAgICAgICAwIC0gOTk5OVxuICAgICAgICBtYXRjaDF0bzYgPSAvWystXT9cXGR7MSw2fS8sIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICAgICAgbWF0Y2hVbnNpZ25lZCA9IC9cXGQrLywgLy8gICAgICAgMCAtIGluZlxuICAgICAgICBtYXRjaFNpZ25lZCA9IC9bKy1dP1xcZCsvLCAvLyAgICAtaW5mIC0gaW5mXG4gICAgICAgIG1hdGNoT2Zmc2V0ID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpLCAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICAgICAgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpLCAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgICAgICBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy8sIC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG4gICAgICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgICAgICAvLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG4gICAgICAgIG1hdGNoV29yZCA9XG4gICAgICAgICAgICAvWzAtOV17MCwyNTZ9WydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGMDdcXHVGRjEwLVxcdUZGRUZdezEsMjU2fXxbXFx1MDYwMC1cXHUwNkZGXFwvXXsxLDI1Nn0oXFxzKj9bXFx1MDYwMC1cXHUwNkZGXXsxLDI1Nn0pezEsMn0vaSxcbiAgICAgICAgcmVnZXhlcztcblxuICAgIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4odG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpXG4gICAgICAgICAgICA/IHJlZ2V4XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4ID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykge1xuICAgICAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG4gICAgfVxuXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4RXNjYXBlKFxuICAgICAgICAgICAgc1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdcXFxcJywgJycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbih0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBmdW5jID0gY2FsbGJhY2ssXG4gICAgICAgICAgICB0b2tlbkxlbjtcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRva2VuID0gW3Rva2VuXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOdW1iZXIoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2NhbGxiYWNrXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5MZW4gPSB0b2tlbi5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbkxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5baV1dID0gZnVuYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtQYXJzZVRva2VuKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBZRUFSID0gMCxcbiAgICAgICAgTU9OVEggPSAxLFxuICAgICAgICBEQVRFID0gMixcbiAgICAgICAgSE9VUiA9IDMsXG4gICAgICAgIE1JTlVURSA9IDQsXG4gICAgICAgIFNFQ09ORCA9IDUsXG4gICAgICAgIE1JTExJU0VDT05EID0gNixcbiAgICAgICAgV0VFSyA9IDcsXG4gICAgICAgIFdFRUtEQVkgPSA4O1xuXG4gICAgZnVuY3Rpb24gbW9kKG4sIHgpIHtcbiAgICAgICAgcmV0dXJuICgobiAlIHgpICsgeCkgJSB4O1xuICAgIH1cblxuICAgIHZhciBpbmRleE9mO1xuXG4gICAgaWYgKEFycmF5LnByb3RvdHlwZS5pbmRleE9mKSB7XG4gICAgICAgIGluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleE9mID0gZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgIC8vIEkga25vd1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldID09PSBvKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzSW5Nb250aCh5ZWFyLCBtb250aCkge1xuICAgICAgICBpZiAoaXNOYU4oeWVhcikgfHwgaXNOYU4obW9udGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb2RNb250aCA9IG1vZChtb250aCwgMTIpO1xuICAgICAgICB5ZWFyICs9IChtb250aCAtIG1vZE1vbnRoKSAvIDEyO1xuICAgICAgICByZXR1cm4gbW9kTW9udGggPT09IDFcbiAgICAgICAgICAgID8gaXNMZWFwWWVhcih5ZWFyKVxuICAgICAgICAgICAgICAgID8gMjlcbiAgICAgICAgICAgICAgICA6IDI4XG4gICAgICAgICAgICA6IDMxIC0gKChtb2RNb250aCAlIDcpICUgMik7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ00nLCBbJ01NJywgMl0sICdNbycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU1NJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21vbnRoJywgJ00nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21vbnRoJywgOCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdNJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTU0nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLm1vbnRoc1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICAgICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZE1vbnRoID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzID1cbiAgICAgICAgICAgICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdChcbiAgICAgICAgICAgICAgICAnXydcbiAgICAgICAgICAgICksXG4gICAgICAgIGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCA9XG4gICAgICAgICAgICAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksXG4gICAgICAgIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy8sXG4gICAgICAgIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0TW9udGhzUmVnZXggPSBtYXRjaFdvcmQ7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKVxuICAgICAgICAgICAgICAgID8gdGhpcy5fbW9udGhzXG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpXG4gICAgICAgICAgICA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldXG4gICAgICAgICAgICA6IHRoaXMuX21vbnRoc1tcbiAgICAgICAgICAgICAgICAgICh0aGlzLl9tb250aHMuaXNGb3JtYXQgfHwgTU9OVEhTX0lOX0ZPUk1BVCkudGVzdChmb3JtYXQpXG4gICAgICAgICAgICAgICAgICAgICAgPyAnZm9ybWF0J1xuICAgICAgICAgICAgICAgICAgICAgIDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgICAgIF1bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydClcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1Nob3J0XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KVxuICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldXG4gICAgICAgICAgICA6IHRoaXMuX21vbnRoc1Nob3J0W1xuICAgICAgICAgICAgICAgICAgTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgICAgICBdW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGlpLFxuICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQoXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzUGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID1cbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnTU1NTScgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnTU1NJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHNldE1vbnRoKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgICAgIGlmICghaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TW9udGgodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzU2hvcnRSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3J0UGllY2VzID0gW10sXG4gICAgICAgICAgICBsb25nUGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG1vbTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgICAgICByZXR1cm4geSA8PSA5OTk5ID8gemVyb0ZpbGwoeSwgNCkgOiAnKycgKyB5O1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsIDRdLCAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCA1XSwgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPVxuICAgICAgICAgICAgaW5wdXQubGVuZ3RoID09PSAyID8gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIoKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlKHkpIHtcbiAgICAgICAgdmFyIGRhdGUsIGFyZ3M7XG4gICAgICAgIC8vIHRoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICBhcmdzWzBdID0geSArIDQwMDtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmdzKSk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBzdGFydC1vZi1maXJzdC13ZWVrIC0gc3RhcnQtb2YteWVhclxuICAgIGZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgICAgICBmd2QgPSA3ICsgZG93IC0gZG95LFxuICAgICAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgICAgIHJlc1llYXIsXG4gICAgICAgICAgICByZXNEYXlPZlllYXI7XG5cbiAgICAgICAgaWYgKGRheU9mWWVhciA8PSAwKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKGRheU9mWWVhciA+IGRheXNJblllYXIoeWVhcikpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICAgICAgZGF5T2ZZZWFyOiByZXNEYXlPZlllYXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWsgPSBNYXRoLmZsb29yKChtb20uZGF5T2ZZZWFyKCkgLSB3ZWVrT2Zmc2V0IC0gMSkgLyA3KSArIDEsXG4gICAgICAgICAgICByZXNXZWVrLFxuICAgICAgICAgICAgcmVzWWVhcjtcblxuICAgICAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyICsgMSwgZG93LCBkb3kpO1xuICAgICAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2VlaycsIDUpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigndycsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihcbiAgICAgICAgWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSxcbiAgICAgICAgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vlayhtb20pIHtcbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrID0ge1xuICAgICAgICBkb3c6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3k6IDYsIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDZ0aCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayhpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkud2VlaztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkJywgMCwgJ2RvJywgJ2RheScpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZScsIDAsIDAsICd3ZWVrZGF5Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ0UnLCAwLCAwLCAnaXNvV2Vla2RheScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXknLCAnZCcpO1xuICAgIGFkZFVuaXRBbGlhcygnd2Vla2RheScsICdlJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrZGF5JywgJ0UnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2Vla2RheScsIDExKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2QnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2UnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0UnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2RkJywgJ2RkZCcsICdkZGRkJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgd2Vla2RheSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSB3ZWVrZGF5IG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZFxuICAgICAgICBpZiAod2Vla2RheSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWVrLmQgPSB3ZWVrZGF5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZFdlZWtkYXkgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkJywgJ2UnLCAnRSddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc05hTihpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KSAlIDcgfHwgNztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNOYU4oaW5wdXQpID8gbnVsbCA6IGlucHV0O1xuICAgIH1cblxuICAgIC8vIExPQ0FMRVNcbiAgICBmdW5jdGlvbiBzaGlmdFdlZWtkYXlzKHdzLCBuKSB7XG4gICAgICAgIHJldHVybiB3cy5zbGljZShuLCA3KS5jb25jYXQod3Muc2xpY2UoMCwgbikpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPVxuICAgICAgICAgICAgJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxuICAgICAgICBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyksXG4gICAgICAgIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKSxcbiAgICAgICAgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQsXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQsXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciB3ZWVrZGF5cyA9IGlzQXJyYXkodGhpcy5fd2Vla2RheXMpXG4gICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzXG4gICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzW1xuICAgICAgICAgICAgICAgICAgbSAmJiBtICE9PSB0cnVlICYmIHRoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICAgID8gJ2Zvcm1hdCdcbiAgICAgICAgICAgICAgICAgICAgICA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgICAgICBdO1xuICAgICAgICByZXR1cm4gbSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyBzaGlmdFdlZWtkYXlzKHdlZWtkYXlzLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogbVxuICAgICAgICAgICAgPyB3ZWVrZGF5c1ttLmRheSgpXVxuICAgICAgICAgICAgOiB3ZWVrZGF5cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0KG0pIHtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c1Nob3J0LCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogbVxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldXG4gICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4obSkge1xuICAgICAgICByZXR1cm4gbSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzTWluLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogbVxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXVxuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c01pbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGlpLFxuICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihcbiAgICAgICAgICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgICkudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQoXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2Uod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZSQxLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG5cbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID1cbiAgICAgICAgICAgICAgICAgICAgJ14nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArXG4gICAgICAgICAgICAgICAgICAgICd8XicgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnfF4nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdkZGRkJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnZGRkJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayhpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayhpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayhpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKSB8fCA3O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla2RheXNSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5QaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIHNob3J0UGllY2VzID0gW10sXG4gICAgICAgICAgICBsb25nUGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIG1pbnAsXG4gICAgICAgICAgICBzaG9ydHAsXG4gICAgICAgICAgICBsb25ncDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBtaW5wID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5c01pbihtb20sICcnKSk7XG4gICAgICAgICAgICBzaG9ydHAgPSByZWdleEVzY2FwZSh0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ3AgPSByZWdleEVzY2FwZSh0aGlzLndlZWtkYXlzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbWluUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcbiAgICBhZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgaEZvcm1hdC5hcHBseSh0aGlzKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpXG4gICAgICAgICk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAnJyArXG4gICAgICAgICAgICB0aGlzLmhvdXJzKCkgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0odG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKFxuICAgICAgICAgICAgICAgIHRoaXMuaG91cnMoKSxcbiAgICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgICAgICBsb3dlcmNhc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1lcmlkaWVtKCdhJywgdHJ1ZSk7XG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2hvdXInLCAxMyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBmdW5jdGlvbiBtYXRjaE1lcmlkaWVtKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0gnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2snLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2trJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcbiAgICBhZGRSZWdleFRva2VuKCdobW1zcycsIG1hdGNoNXRvNik7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tJywgbWF0Y2gzdG80KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaycsICdrayddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIGtJbnB1dCA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSBrSW5wdXQgPT09IDI0ID8gMCA6IGtJbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICAgICAgY29uZmlnLl9tZXJpZGllbSA9IGlucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignaG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignaG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0LFxuICAgICAgICAgICAgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNCxcbiAgICAgICAgICAgIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUlzUE0oaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuIChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSA9IC9bYXBdXFwuP20/XFwuPy9pLFxuICAgICAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAgICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgdGhleSB3YW50LiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAgICAgLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4gICAgICAgIC8vIHRoaXMgcnVsZS5cbiAgICAgICAgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbShob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlLFxuICAgIH07XG5cbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG4gICAgdmFyIGxvY2FsZXMgPSB7fSxcbiAgICAgICAgbG9jYWxlRmFtaWxpZXMgPSB7fSxcbiAgICAgICAgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gY29tbW9uUHJlZml4KGFycjEsIGFycjIpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBtaW5sID0gTWF0aC5taW4oYXJyMS5sZW5ndGgsIGFycjIubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1pbmw7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWlubDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBuZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgIG5leHQubGVuZ3RoID49IGogJiZcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uUHJlZml4KHNwbGl0LCBuZXh0KSA+PSBqIC0gMVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsZU5hbWVTYW5lKG5hbWUpIHtcbiAgICAgICAgLy8gUHJldmVudCBuYW1lcyB0aGF0IGxvb2sgbGlrZSBmaWxlc3lzdGVtIHBhdGhzLCBpLmUgY29udGFpbiAnLycgb3IgJ1xcJ1xuICAgICAgICByZXR1cm4gbmFtZS5tYXRjaCgnXlteL1xcXFxcXFxcXSokJykgIT0gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGwsXG4gICAgICAgICAgICBhbGlhc2VkUmVxdWlyZTtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgbW9kdWxlICYmXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyAmJlxuICAgICAgICAgICAgaXNMb2NhbGVOYW1lU2FuZShuYW1lKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlID0gcmVxdWlyZTtcbiAgICAgICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIG1hcmsgYXMgbm90IGZvdW5kIHRvIGF2b2lkIHJlcGVhdGluZyBleHBlbnNpdmUgZmlsZSByZXF1aXJlIGNhbGwgY2F1c2luZyBoaWdoIENQVVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdHJ5aW5nIHRvIGZpbmQgZW4tVVMsIGVuX1VTLCBlbi11cyBmb3IgZXZlcnkgZm9ybWF0IGNhbGxcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbnVsbDsgLy8gbnVsbCBtZWFucyBub3QgZm91bmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxvY2FsZSBrZXkuXG4gICAgZnVuY3Rpb24gZ2V0U2V0R2xvYmFsTG9jYWxlKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy93YXJuIHVzZXIgaWYgYXJndW1lbnRzIGFyZSBwYXNzZWQgYnV0IHRoZSBsb2NhbGUgY291bGQgbm90IGJlIHNldFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAnTG9jYWxlICcgKyBrZXkgKyAnIG5vdCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gbG9hZCBpdD8nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoXG4gICAgICAgICAgICAgICAgICAgICdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICd1c2UgbW9tZW50LnVwZGF0ZUxvY2FsZShsb2NhbGVOYW1lLCBjb25maWcpIHRvIGNoYW5nZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbiBleGlzdGluZyBsb2NhbGUuIG1vbWVudC5kZWZpbmVMb2NhbGUobG9jYWxlTmFtZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29uZmlnKSBzaG91bGQgb25seSBiZSB1c2VkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZGVmaW5lLWxvY2FsZS8gZm9yIG1vcmUgaW5mby4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXS5fY29uZmlnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoY29uZmlnLnBhcmVudExvY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHRtcExvY2FsZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsICYmIGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgY2hpbGQgbG9jYWxlIGluLXBsYWNlIHRvIGF2b2lkIG1lbW9yeS1sZWFrc1xuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0uc2V0KG1lcmdlQ29uZmlncyhsb2NhbGVzW25hbWVdLl9jb25maWcsIGNvbmZpZykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNRVJHRVxuICAgICAgICAgICAgICAgIHRtcExvY2FsZSA9IGxvYWRMb2NhbGUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IHRtcExvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVMb2NhbGUgaXMgY2FsbGVkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGFiYnIgc28gaXQgd2lsbCBoYXZlIGEgbmFtZSAoZ2V0dGVycyByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgLy8gdW5kZWZpbmVkIG90aGVyd2lzZSkuXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgICAgIGxvY2FsZS5wYXJlbnRMb2NhbGUgPSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFzcyBudWxsIGZvciBjb25maWcgdG8gdW51cGRhdGUsIHVzZWZ1bCBmb3IgdGVzdHNcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBnZXRTZXRHbG9iYWxMb2NhbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgbG9jYWxlIGRhdGFcbiAgICBmdW5jdGlvbiBnZXRMb2NhbGUoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RMb2NhbGVzKCkge1xuICAgICAgICByZXR1cm4ga2V5cyhsb2NhbGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93KG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93LFxuICAgICAgICAgICAgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdIDwgMCB8fCBhW01PTlRIXSA+IDExXG4gICAgICAgICAgICAgICAgICAgID8gTU9OVEhcbiAgICAgICAgICAgICAgICAgICAgOiBhW0RBVEVdIDwgMSB8fCBhW0RBVEVdID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pXG4gICAgICAgICAgICAgICAgICAgID8gREFURVxuICAgICAgICAgICAgICAgICAgICA6IGFbSE9VUl0gPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgYVtIT1VSXSA+IDI0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgKGFbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChhW01JTlVURV0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbU0VDT05EXSAhPT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gIT09IDApKVxuICAgICAgICAgICAgICAgICAgICA/IEhPVVJcbiAgICAgICAgICAgICAgICAgICAgOiBhW01JTlVURV0gPCAwIHx8IGFbTUlOVVRFXSA+IDU5XG4gICAgICAgICAgICAgICAgICAgID8gTUlOVVRFXG4gICAgICAgICAgICAgICAgICAgIDogYVtTRUNPTkRdIDwgMCB8fCBhW1NFQ09ORF0gPiA1OVxuICAgICAgICAgICAgICAgICAgICA/IFNFQ09ORFxuICAgICAgICAgICAgICAgICAgICA6IGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OVxuICAgICAgICAgICAgICAgICAgICA/IE1JTExJU0VDT05EXG4gICAgICAgICAgICAgICAgICAgIDogLTE7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmXG4gICAgICAgICAgICAgICAgKG92ZXJmbG93IDwgWUVBUiB8fCBvdmVyZmxvdyA+IERBVEUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFSztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUtEQVk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gaXNvIDg2MDEgcmVnZXhcbiAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbiAgICB2YXIgZXh0ZW5kZWRJc29SZWdleCA9XG4gICAgICAgICAgICAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbKy1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcbiAgICAgICAgYmFzaWNJc29SZWdleCA9XG4gICAgICAgICAgICAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkfCkpKD86KFR8ICkoXFxkXFxkKD86XFxkXFxkKD86XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvLFxuICAgICAgICB0elJlZ2V4ID0gL1p8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8vLFxuICAgICAgICBpc29EYXRlcyA9IFtcbiAgICAgICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICAgICAgWydZWVlZLU1NLUREJywgL1xcZHs0fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgICAgICBbJ0dHR0ctW1ddV1ctRScsIC9cXGR7NH0tV1xcZFxcZC1cXGQvXSxcbiAgICAgICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgICAgIFsnWVlZWS1EREQnLCAvXFxkezR9LVxcZHszfS9dLFxuICAgICAgICAgICAgWydZWVlZLU1NJywgL1xcZHs0fS1cXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICAgICAgICAgIFsnWVlZWU1NREQnLCAvXFxkezh9L10sXG4gICAgICAgICAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgICAgICAgICAgWydHR0dHW1ddV1cnLCAvXFxkezR9V1xcZHsyfS8sIGZhbHNlXSxcbiAgICAgICAgICAgIFsnWVlZWURERCcsIC9cXGR7N30vXSxcbiAgICAgICAgICAgIFsnWVlZWU1NJywgL1xcZHs2fS8sIGZhbHNlXSxcbiAgICAgICAgICAgIFsnWVlZWScsIC9cXGR7NH0vLCBmYWxzZV0sXG4gICAgICAgIF0sXG4gICAgICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcbiAgICAgICAgaXNvVGltZXMgPSBbXG4gICAgICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgICAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgICAgICAgICAgWydISDptbTpzcycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICAgICAgWydISDptbScsIC9cXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgICAgIFsnSEhtbXNzLFNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkLFxcZCsvXSxcbiAgICAgICAgICAgIFsnSEhtbXNzJywgL1xcZFxcZFxcZFxcZFxcZFxcZC9dLFxuICAgICAgICAgICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgICAgICAgICAgWydISCcsIC9cXGRcXGQvXSxcbiAgICAgICAgXSxcbiAgICAgICAgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKCgtP1xcZCspL2ksXG4gICAgICAgIC8vIFJGQyAyODIyIHJlZ2V4OiBGb3IgZGV0YWlscyBzZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzI4MjIjc2VjdGlvbi0zLjNcbiAgICAgICAgcmZjMjgyMiA9XG4gICAgICAgICAgICAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLD9cXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KFsrLV1cXGR7NH0pKSQvLFxuICAgICAgICBvYnNPZmZzZXRzID0ge1xuICAgICAgICAgICAgVVQ6IDAsXG4gICAgICAgICAgICBHTVQ6IDAsXG4gICAgICAgICAgICBFRFQ6IC00ICogNjAsXG4gICAgICAgICAgICBFU1Q6IC01ICogNjAsXG4gICAgICAgICAgICBDRFQ6IC01ICogNjAsXG4gICAgICAgICAgICBDU1Q6IC02ICogNjAsXG4gICAgICAgICAgICBNRFQ6IC02ICogNjAsXG4gICAgICAgICAgICBNU1Q6IC03ICogNjAsXG4gICAgICAgICAgICBQRFQ6IC03ICogNjAsXG4gICAgICAgICAgICBQU1Q6IC04ICogNjAsXG4gICAgICAgIH07XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgICAgICBhbGxvd1RpbWUsXG4gICAgICAgICAgICBkYXRlRm9ybWF0LFxuICAgICAgICAgICAgdGltZUZvcm1hdCxcbiAgICAgICAgICAgIHR6Rm9ybWF0LFxuICAgICAgICAgICAgaXNvRGF0ZXNMZW4gPSBpc29EYXRlcy5sZW5ndGgsXG4gICAgICAgICAgICBpc29UaW1lc0xlbiA9IGlzb1RpbWVzLmxlbmd0aDtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXNMZW47IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXNMZW47IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKFxuICAgICAgICB5ZWFyU3RyLFxuICAgICAgICBtb250aFN0cixcbiAgICAgICAgZGF5U3RyLFxuICAgICAgICBob3VyU3RyLFxuICAgICAgICBtaW51dGVTdHIsXG4gICAgICAgIHNlY29uZFN0clxuICAgICkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgdW50cnVuY2F0ZVllYXIoeWVhclN0ciksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXG4gICAgICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGhvdXJTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApLFxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChzZWNvbmRTdHIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHNlY29uZFN0ciwgMTApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW50cnVuY2F0ZVllYXIoeWVhclN0cikge1xuICAgICAgICB2YXIgeWVhciA9IHBhcnNlSW50KHllYXJTdHIsIDEwKTtcbiAgICAgICAgaWYgKHllYXIgPD0gNDkpIHtcbiAgICAgICAgICAgIHJldHVybiAyMDAwICsgeWVhcjtcbiAgICAgICAgfSBlbHNlIGlmICh5ZWFyIDw9IDk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIDE5MDAgKyB5ZWFyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5ZWFyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXByb2Nlc3NSRkMyODIyKHMpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2UgYW5kIHJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgcmV0dXJuIHNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXChbXigpXSpcXCl8W1xcblxcdF0vZywgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxcc1xccyovLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1dlZWtkYXkod2Vla2RheVN0ciwgcGFyc2VkSW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAod2Vla2RheVN0cikge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW5kZW50IGRheS1vZi13ZWVrIGNoZWNrLlxuICAgICAgICAgICAgdmFyIHdlZWtkYXlQcm92aWRlZCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0ciksXG4gICAgICAgICAgICAgICAgd2Vla2RheUFjdHVhbCA9IG5ldyBEYXRlKFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFswXSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMV0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElucHV0WzJdXG4gICAgICAgICAgICAgICAgKS5nZXREYXkoKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQob2JzT2Zmc2V0LCBtaWxpdGFyeU9mZnNldCwgbnVtT2Zmc2V0KSB7XG4gICAgICAgIGlmIChvYnNPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNPZmZzZXRzW29ic09mZnNldF07XG4gICAgICAgIH0gZWxzZSBpZiAobWlsaXRhcnlPZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBvbmx5IGFsbG93ZWQgbWlsaXRhcnkgdHogaXMgWlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaG0gPSBwYXJzZUludChudW1PZmZzZXQsIDEwKSxcbiAgICAgICAgICAgICAgICBtID0gaG0gJSAxMDAsXG4gICAgICAgICAgICAgICAgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGggKiA2MCArIG07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKSxcbiAgICAgICAgICAgIHBhcnNlZEFycmF5O1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHBhcnNlZEFycmF5ID0gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcbiAgICAgICAgICAgICAgICBtYXRjaFs0XSxcbiAgICAgICAgICAgICAgICBtYXRjaFszXSxcbiAgICAgICAgICAgICAgICBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICBtYXRjaFs1XSxcbiAgICAgICAgICAgICAgICBtYXRjaFs2XSxcbiAgICAgICAgICAgICAgICBtYXRjaFs3XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghY2hlY2tXZWVrZGF5KG1hdGNoWzFdLCBwYXJzZWRBcnJheSwgY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnLl9hID0gcGFyc2VkQXJyYXk7XG4gICAgICAgICAgICBjb25maWcuX3R6bSA9IGNhbGN1bGF0ZU9mZnNldChtYXRjaFs4XSwgbWF0Y2hbOV0sIG1hdGNoWzEwXSk7XG5cbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGNyZWF0ZVVUQ0RhdGUuYXBwbHkobnVsbCwgY29uZmlnLl9hKTtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnJmYzI4MjIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gMSkgQVNQLk5FVCwgMikgSVNPLCAzKSBSRkMgMjgyMiBmb3JtYXRzLCBvciA0KSBvcHRpb25hbCBmYWxsYmFjayBpZiBwYXJzaW5nIGlzbid0IHN0cmljdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX3N0cmljdCkge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcbiAgICAgICAgICAgICd3aGljaCBpcyBub3QgcmVsaWFibGUgYWNyb3NzIGFsbCBicm93c2VycyBhbmQgdmVyc2lvbnMuIE5vbiBSRkMyODIyL0lTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xuICAgICAgICAgICAgJ2Rpc2NvdXJhZ2VkLiBQbGVhc2UgcmVmZXIgdG8gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgLy8gaG9va3MgaXMgYWN0dWFsbHkgdGhlIGV4cG9ydGVkIG1vbWVudCBvYmplY3RcbiAgICAgICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENNb250aCgpLFxuICAgICAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRNb250aCgpLCBub3dWYWx1ZS5nZXREYXRlKCldO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgICBpbnB1dCA9IFtdLFxuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICBleHBlY3RlZFdlZWtkYXksXG4gICAgICAgICAgICB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHxcbiAgICAgICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9PT0gMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPVxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9PSBudWxsID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdGVkV2Vla2RheSA9IGNvbmZpZy5fdXNlVVRDXG4gICAgICAgICAgICA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKVxuICAgICAgICAgICAgOiBjb25maWcuX2QuZ2V0RGF5KCk7XG5cbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc21hdGNoaW5nIGRheSBvZiB3ZWVrXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fdyAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgY29uZmlnLl93LmQgIT09IGV4cGVjdGVkV2Vla2RheVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdywgY3VyV2VlaztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKFxuICAgICAgICAgICAgICAgIHcuR0csXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdLFxuICAgICAgICAgICAgICAgIHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCBjdXJXZWVrLnllYXIpO1xuXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgd2Vlay5cbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWtkYXlPdmVyZmxvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXAgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG4gICAgaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBSRkMgMjgyMiBmb3JtXG4gICAgaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLlJGQ18yODIyKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHBhcnNlZElucHV0LFxuICAgICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwLFxuICAgICAgICAgICAgZXJhLFxuICAgICAgICAgICAgdG9rZW5MZW47XG5cbiAgICAgICAgdG9rZW5zID1cbiAgICAgICAgICAgIGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcbiAgICAgICAgdG9rZW5MZW4gPSB0b2tlbnMubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5MZW47IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fFxuICAgICAgICAgICAgICAgIFtdKVswXTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9XG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChcbiAgICAgICAgICAgIGNvbmZpZy5fbG9jYWxlLFxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdLFxuICAgICAgICAgICAgY29uZmlnLl9tZXJpZGllbVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGhhbmRsZSBlcmFcbiAgICAgICAgZXJhID0gZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZXJhO1xuICAgICAgICBpZiAoZXJhICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSBjb25maWcuX2xvY2FsZS5lcmFzQ29udmVydFllYXIoZXJhLCBjb25maWcuX2FbWUVBUl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSxcbiAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmQsXG4gICAgICAgICAgICBiZXN0Rm9ybWF0SXNWYWxpZCA9IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlnZkxlbiA9IGNvbmZpZy5fZi5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGNvbmZpZ2ZMZW4gPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWdmTGVuOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKGlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmICghYmVzdEZvcm1hdElzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQgfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZEZvcm1hdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0Rm9ybWF0SXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSksXG4gICAgICAgICAgICBkYXlPckRhdGUgPSBpLmRheSA9PT0gdW5kZWZpbmVkID8gaS5kYXRlIDogaS5kYXk7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChcbiAgICAgICAgICAgIFtpLnllYXIsIGkubW9udGgsIGRheU9yRGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLFxuICAgICAgICAgICAgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGdldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoeyBudWxsSW5wdXQ6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gdHJ1ZSB8fCBmb3JtYXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9jYWxlID09PSB0cnVlIHx8IGxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF4KCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICtuZXcgRGF0ZSgpO1xuICAgIH07XG5cbiAgICB2YXIgb3JkZXJpbmcgPSBbXG4gICAgICAgICd5ZWFyJyxcbiAgICAgICAgJ3F1YXJ0ZXInLFxuICAgICAgICAnbW9udGgnLFxuICAgICAgICAnd2VlaycsXG4gICAgICAgICdkYXknLFxuICAgICAgICAnaG91cicsXG4gICAgICAgICdtaW51dGUnLFxuICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgJ21pbGxpc2Vjb25kJyxcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gZmFsc2UsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgb3JkZXJMZW4gPSBvcmRlcmluZy5sZW5ndGg7XG4gICAgICAgIGZvciAoa2V5IGluIG0pIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wKG0sIGtleSkgJiZcbiAgICAgICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgICAgICBpbmRleE9mLmNhbGwob3JkZXJpbmcsIGtleSkgIT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgIChtW2tleV0gPT0gbnVsbCB8fCAhaXNOYU4obVtrZXldKSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3JkZXJMZW47ICsraSkge1xuICAgICAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IG5vcm1hbGl6ZWRJbnB1dC5pc29XZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID1cbiAgICAgICAgICAgICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgKyB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgKyBxdWFydGVycyAqIDMgKyB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpLFxuICAgICAgICAgICAgICAgIHNpZ24gPSAnKyc7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgc2lnbiArXG4gICAgICAgICAgICAgICAgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yICtcbiAgICAgICAgICAgICAgICB6ZXJvRmlsbCh+fm9mZnNldCAlIDYwLCAyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpLFxuICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIG1pbnV0ZXM7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY2h1bmsgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgICAgIHBhcnRzID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICAgICAgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgPyAwIDogcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPVxuICAgICAgICAgICAgICAgIChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LnZhbHVlT2YoKVxuICAgICAgICAgICAgICAgICAgICA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0KG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUsIGtlZXBNaW51dGVzKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNiAmJiAha2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFN1YnRyYWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRab25lKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0KGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IGlucHV0ID8gY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge30sXG4gICAgICAgICAgICBvdGhlcjtcblxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID1cbiAgICAgICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJiBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXigtfFxcKyk/KD86KFxcZCopWy4gXSk/KFxcZCspOihcXGQrKSg/OjooXFxkKykoXFwuXFxkKik/KT8kLyxcbiAgICAgICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAgICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgICAgICAvLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XG4gICAgICAgIGlzb1JlZ2V4ID1cbiAgICAgICAgICAgIC9eKC18XFwrKT9QKD86KFstK10/WzAtOSwuXSopWSk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopVyk/KD86KFstK10/WzAtOSwuXSopRCk/KD86VCg/OihbLStdP1swLTksLl0qKUgpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVMpPyk/JC87XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEdXJhdGlvbihpbnB1dCwga2V5KSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGlucHV0LFxuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgYWdhaW5zdCByZWdleHAgaXMgZXhwZW5zaXZlLCBkbyBpdCBvbiBkZW1hbmRcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcbiAgICAgICAgICAgIHNpZ24sXG4gICAgICAgICAgICByZXQsXG4gICAgICAgICAgICBkaWZmUmVzO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgbXM6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZDogaW5wdXQuX2RheXMsXG4gICAgICAgICAgICAgICAgTTogaW5wdXQuX21vbnRocyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpIHx8ICFpc05hTigraW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSAraW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9ICtpbnB1dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSBtYXRjaFsxXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICBkOiB0b0ludChtYXRjaFtEQVRFXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIGg6IHRvSW50KG1hdGNoW0hPVVJdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbTogdG9JbnQobWF0Y2hbTUlOVVRFXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIHM6IHRvSW50KG1hdGNoW1NFQ09ORF0pICogc2lnbixcbiAgICAgICAgICAgICAgICBtczogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiwgLy8gdGhlIG1pbGxpc2Vjb25kIGRlY2ltYWwgcG9pbnQgaXMgaW5jbHVkZWQgaW4gdGhlIG1hdGNoXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IGlzb1JlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IG1hdGNoWzFdID09PSAnLScgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5OiBwYXJzZUlzbyhtYXRjaFsyXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgTTogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHc6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBkOiBwYXJzZUlzbyhtYXRjaFs1XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIG06IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgICAgICBzOiBwYXJzZUlzbyhtYXRjaFs4XSwgc2lnbiksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWRcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAoJ2Zyb20nIGluIGR1cmF0aW9uIHx8ICd0bycgaW4gZHVyYXRpb24pXG4gICAgICAgICkge1xuICAgICAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKFxuICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKGR1cmF0aW9uLnRvKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICBkdXJhdGlvbi5NID0gZGlmZlJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBuZXcgRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2xvY2FsZScpKSB7XG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19pc1ZhbGlkJykpIHtcbiAgICAgICAgICAgIHJldC5faXNWYWxpZCA9IGlucHV0Ll9pc1ZhbGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBjcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcbiAgICBjcmVhdGVEdXJhdGlvbi5pbnZhbGlkID0gY3JlYXRlSW52YWxpZCQxO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VJc28oaW5wLCBzaWduKSB7XG4gICAgICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXG4gICAgICAgIC8vIGNvbnZlcnRzIGZsb2F0cyB0byBpbnRzLlxuICAgICAgICAvLyBpbnAgbWF5IGJlIHVuZGVmaW5lZCwgc28gY2FyZWZ1bCBjYWxsaW5nIHJlcGxhY2Ugb24gaXQuXG4gICAgICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xuICAgICAgICAvLyBhcHBseSBzaWduIHdoaWxlIHdlJ3JlIGF0IGl0XG4gICAgICAgIHJldHVybiAoaXNOYU4ocmVzKSA/IDAgOiByZXMpICogc2lnbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXMgPSB7fTtcblxuICAgICAgICByZXMubW9udGhzID1cbiAgICAgICAgICAgIG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgKyAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XG4gICAgICAgIGlmIChiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykuaXNBZnRlcihvdGhlcikpIHtcbiAgICAgICAgICAgIC0tcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSArb3RoZXIgLSArYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgaWYgKCEoYmFzZS5pc1ZhbGlkKCkgJiYgb3RoZXIuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyID0gY2xvbmVXaXRoT2Zmc2V0KG90aGVyLCBiYXNlKTtcbiAgICAgICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xuICAgICAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9IC1yZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgcmVzLm1vbnRocyA9IC1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvLyBUT0RPOiByZW1vdmUgJ25hbWUnIGFyZyBhZnRlciBkZXByZWNhdGlvbiBpcyByZW1vdmVkXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsLCBwZXJpb2QpIHtcbiAgICAgICAgICAgIHZhciBkdXIsIHRtcDtcbiAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxuICAgICAgICAgICAgaWYgKHBlcmlvZCAhPT0gbnVsbCAmJiAhaXNOYU4oK3BlcmlvZCkpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICdtb21lbnQoKS4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyhudW1iZXIsIHBlcmlvZCkuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2FkZC1pbnZlcnRlZC1wYXJhbS8gZm9yIG1vcmUgaW5mby4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0bXAgPSB2YWw7XG4gICAgICAgICAgICAgICAgdmFsID0gcGVyaW9kO1xuICAgICAgICAgICAgICAgIHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZHVyID0gY3JlYXRlRHVyYXRpb24odmFsLCBwZXJpb2QpO1xuICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gZHVyYXRpb24uX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSBhYnNSb3VuZChkdXJhdGlvbi5fZGF5cyksXG4gICAgICAgICAgICBtb250aHMgPSBhYnNSb3VuZChkdXJhdGlvbi5fbW9udGhzKTtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1vbnRocykge1xuICAgICAgICAgICAgc2V0TW9udGgobW9tLCBnZXQobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgc2V0JDEobW9tLCAnRGF0ZScsIGdldChtb20sICdEYXRlJykgKyBkYXlzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaWxsaXNlY29uZHMpIHtcbiAgICAgICAgICAgIG1vbS5fZC5zZXRUaW1lKG1vbS5fZC52YWx1ZU9mKCkgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZU9mZnNldCkge1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFkZCA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKSxcbiAgICAgICAgc3VidHJhY3QgPSBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0Jyk7XG5cbiAgICBmdW5jdGlvbiBpc1N0cmluZyhpbnB1dCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyB8fCBpbnB1dCBpbnN0YW5jZW9mIFN0cmluZztcbiAgICB9XG5cbiAgICAvLyB0eXBlIE1vbWVudElucHV0ID0gTW9tZW50IHwgRGF0ZSB8IHN0cmluZyB8IG51bWJlciB8IChudW1iZXIgfCBzdHJpbmcpW10gfCBNb21lbnRJbnB1dE9iamVjdCB8IHZvaWQ7IC8vIG51bGwgfCB1bmRlZmluZWRcbiAgICBmdW5jdGlvbiBpc01vbWVudElucHV0KGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpc01vbWVudChpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzRGF0ZShpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzU3RyaW5nKGlucHV0KSB8fFxuICAgICAgICAgICAgaXNOdW1iZXIoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc051bWJlck9yU3RyaW5nQXJyYXkoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc01vbWVudElucHV0T2JqZWN0KGlucHV0KSB8fFxuICAgICAgICAgICAgaW5wdXQgPT09IG51bGwgfHxcbiAgICAgICAgICAgIGlucHV0ID09PSB1bmRlZmluZWRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudElucHV0T2JqZWN0KGlucHV0KSB7XG4gICAgICAgIHZhciBvYmplY3RUZXN0ID0gaXNPYmplY3QoaW5wdXQpICYmICFpc09iamVjdEVtcHR5KGlucHV0KSxcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IGZhbHNlLFxuICAgICAgICAgICAgcHJvcGVydGllcyA9IFtcbiAgICAgICAgICAgICAgICAneWVhcnMnLFxuICAgICAgICAgICAgICAgICd5ZWFyJyxcbiAgICAgICAgICAgICAgICAneScsXG4gICAgICAgICAgICAgICAgJ21vbnRocycsXG4gICAgICAgICAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgICAgICAgICAnTScsXG4gICAgICAgICAgICAgICAgJ2RheXMnLFxuICAgICAgICAgICAgICAgICdkYXknLFxuICAgICAgICAgICAgICAgICdkJyxcbiAgICAgICAgICAgICAgICAnZGF0ZXMnLFxuICAgICAgICAgICAgICAgICdkYXRlJyxcbiAgICAgICAgICAgICAgICAnRCcsXG4gICAgICAgICAgICAgICAgJ2hvdXJzJyxcbiAgICAgICAgICAgICAgICAnaG91cicsXG4gICAgICAgICAgICAgICAgJ2gnLFxuICAgICAgICAgICAgICAgICdtaW51dGVzJyxcbiAgICAgICAgICAgICAgICAnbWludXRlJyxcbiAgICAgICAgICAgICAgICAnbScsXG4gICAgICAgICAgICAgICAgJ3NlY29uZHMnLFxuICAgICAgICAgICAgICAgICdzZWNvbmQnLFxuICAgICAgICAgICAgICAgICdzJyxcbiAgICAgICAgICAgICAgICAnbWlsbGlzZWNvbmRzJyxcbiAgICAgICAgICAgICAgICAnbWlsbGlzZWNvbmQnLFxuICAgICAgICAgICAgICAgICdtcycsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHByb3BlcnR5LFxuICAgICAgICAgICAgcHJvcGVydHlMZW4gPSBwcm9wZXJ0aWVzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydHlMZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gcHJvcGVydHlUZXN0IHx8IGhhc093blByb3AoaW5wdXQsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3RUZXN0ICYmIHByb3BlcnR5VGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlck9yU3RyaW5nQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgdmFyIGFycmF5VGVzdCA9IGlzQXJyYXkoaW5wdXQpLFxuICAgICAgICAgICAgZGF0YVR5cGVUZXN0ID0gZmFsc2U7XG4gICAgICAgIGlmIChhcnJheVRlc3QpIHtcbiAgICAgICAgICAgIGRhdGFUeXBlVGVzdCA9XG4gICAgICAgICAgICAgICAgaW5wdXQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhaXNOdW1iZXIoaXRlbSkgJiYgaXNTdHJpbmcoaW5wdXQpO1xuICAgICAgICAgICAgICAgIH0pLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlUZXN0ICYmIGRhdGFUeXBlVGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0NhbGVuZGFyU3BlYyhpbnB1dCkge1xuICAgICAgICB2YXIgb2JqZWN0VGVzdCA9IGlzT2JqZWN0KGlucHV0KSAmJiAhaXNPYmplY3RFbXB0eShpbnB1dCksXG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBmYWxzZSxcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3NhbWVEYXknLFxuICAgICAgICAgICAgICAgICduZXh0RGF5JyxcbiAgICAgICAgICAgICAgICAnbGFzdERheScsXG4gICAgICAgICAgICAgICAgJ25leHRXZWVrJyxcbiAgICAgICAgICAgICAgICAnbGFzdFdlZWsnLFxuICAgICAgICAgICAgICAgICdzYW1lRWxzZScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHByb3BlcnR5O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBwcm9wZXJ0eVRlc3QgfHwgaGFzT3duUHJvcChpbnB1dCwgcHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdFRlc3QgJiYgcHJvcGVydHlUZXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENhbGVuZGFyRm9ybWF0KG15TW9tZW50LCBub3cpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBteU1vbWVudC5kaWZmKG5vdywgJ2RheXMnLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGRpZmYgPCAtNlxuICAgICAgICAgICAgPyAnc2FtZUVsc2UnXG4gICAgICAgICAgICA6IGRpZmYgPCAtMVxuICAgICAgICAgICAgPyAnbGFzdFdlZWsnXG4gICAgICAgICAgICA6IGRpZmYgPCAwXG4gICAgICAgICAgICA/ICdsYXN0RGF5J1xuICAgICAgICAgICAgOiBkaWZmIDwgMVxuICAgICAgICAgICAgPyAnc2FtZURheSdcbiAgICAgICAgICAgIDogZGlmZiA8IDJcbiAgICAgICAgICAgID8gJ25leHREYXknXG4gICAgICAgICAgICA6IGRpZmYgPCA3XG4gICAgICAgICAgICA/ICduZXh0V2VlaydcbiAgICAgICAgICAgIDogJ3NhbWVFbHNlJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciQxKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gU3VwcG9ydCBmb3Igc2luZ2xlIHBhcmFtZXRlciwgZm9ybWF0cyBvbmx5IG92ZXJsb2FkIHRvIHRoZSBjYWxlbmRhciBmdW5jdGlvblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTW9tZW50SW5wdXQoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIHRpbWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgZm9ybWF0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDYWxlbmRhclNwZWMoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgdGltZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgICAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICAgICAgdmFyIG5vdyA9IHRpbWUgfHwgY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgZm9ybWF0ID0gaG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnLFxuICAgICAgICAgICAgb3V0cHV0ID1cbiAgICAgICAgICAgICAgICBmb3JtYXRzICYmXG4gICAgICAgICAgICAgICAgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKVxuICAgICAgICAgICAgICAgICAgICA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdylcbiAgICAgICAgICAgICAgICAgICAgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChcbiAgICAgICAgICAgIG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxJbnB1dC52YWx1ZU9mKCkgPCB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZWZvcmUoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2Vlbihmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgICAgIHZhciBsb2NhbEZyb20gPSBpc01vbWVudChmcm9tKSA/IGZyb20gOiBjcmVhdGVMb2NhbChmcm9tKSxcbiAgICAgICAgICAgIGxvY2FsVG8gPSBpc01vbWVudCh0bykgPyB0byA6IGNyZWF0ZUxvY2FsKHRvKTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxGcm9tLmlzVmFsaWQoKSAmJiBsb2NhbFRvLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5pc0FmdGVyKGxvY2FsRnJvbSwgdW5pdHMpXG4gICAgICAgICAgICAgICAgOiAhdGhpcy5pc0JlZm9yZShsb2NhbEZyb20sIHVuaXRzKSkgJiZcbiAgICAgICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknXG4gICAgICAgICAgICAgICAgPyB0aGlzLmlzQmVmb3JlKGxvY2FsVG8sIHVuaXRzKVxuICAgICAgICAgICAgICAgIDogIXRoaXMuaXNBZnRlcihsb2NhbFRvLCB1bml0cykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiZcbiAgICAgICAgICAgICAgICBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlcihpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0FmdGVyKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNCZWZvcmUoaW5wdXQsIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCwgem9uZURlbHRhLCBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhhdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0O1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDBcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDZlNDtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzIC0gdGhhdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYoYSwgYikge1xuICAgICAgICBpZiAoYS5kYXRlKCkgPCBiLmRhdGUoKSkge1xuICAgICAgICAgICAgLy8gZW5kLW9mLW1vbnRoIGNhbGN1bGF0aW9ucyB3b3JrIGNvcnJlY3Qgd2hlbiB0aGUgc3RhcnQgbW9udGggaGFzIG1vcmVcbiAgICAgICAgICAgIC8vIGRheXMgdGhhbiB0aGUgZW5kIG1vbnRoLlxuICAgICAgICAgICAgcmV0dXJuIC1tb250aERpZmYoYiwgYSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgICAgICBhbmNob3IyLFxuICAgICAgICAgICAgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbiAgICB9XG5cbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1dGMgPSBrZWVwT2Zmc2V0ICE9PSB0cnVlLFxuICAgICAgICAgICAgbSA9IHV0YyA/IHRoaXMuY2xvbmUoKS51dGMoKSA6IHRoaXM7XG4gICAgICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KFxuICAgICAgICAgICAgICAgIG0sXG4gICAgICAgICAgICAgICAgdXRjXG4gICAgICAgICAgICAgICAgICAgID8gJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXSdcbiAgICAgICAgICAgICAgICAgICAgOiAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICAgICAgaWYgKHV0Yykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSArIHRoaXMudXRjT2Zmc2V0KCkgKiA2MCAqIDEwMDApXG4gICAgICAgICAgICAgICAgICAgIC50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdaJywgZm9ybWF0TW9tZW50KG0sICdaJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQoXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgdXRjID8gJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGh1bWFuIHJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9tZW50IHRoYXQgY2FuXG4gICAgICogYWxzbyBiZSBldmFsdWF0ZWQgdG8gZ2V0IGEgbmV3IG1vbWVudCB3aGljaCBpcyB0aGUgc2FtZVxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL3V0aWwuaHRtbCN1dGlsX2N1c3RvbV9pbnNwZWN0X2Z1bmN0aW9uX29uX29iamVjdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdW5jID0gJ21vbWVudCcsXG4gICAgICAgICAgICB6b25lID0gJycsXG4gICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICB5ZWFyLFxuICAgICAgICAgICAgZGF0ZXRpbWUsXG4gICAgICAgICAgICBzdWZmaXg7XG4gICAgICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICAgICAgem9uZSA9ICdaJztcbiAgICAgICAgfVxuICAgICAgICBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xuICAgICAgICB5ZWFyID0gMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5ID8gJ1lZWVknIDogJ1lZWVlZWSc7XG4gICAgICAgIGRhdGV0aW1lID0gJy1NTS1ERFtUXUhIOm1tOnNzLlNTUyc7XG4gICAgICAgIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdChpbnB1dFN0cmluZykge1xuICAgICAgICBpZiAoIWlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKVxuICAgICAgICAgICAgICAgID8gaG9va3MuZGVmYXVsdEZvcm1hdFV0Y1xuICAgICAgICAgICAgICAgIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8IGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyB0bzogdGhpcywgZnJvbTogdGltZSB9KVxuICAgICAgICAgICAgICAgIC5sb2NhbGUodGhpcy5sb2NhbGUoKSlcbiAgICAgICAgICAgICAgICAuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93KHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0byh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fCBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgZnJvbTogdGhpcywgdG86IHRpbWUgfSlcbiAgICAgICAgICAgICAgICAubG9jYWxlKHRoaXMubG9jYWxlKCkpXG4gICAgICAgICAgICAgICAgLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICAvLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4gICAgLy8gaW5zdGFuY2UuICBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSBsb2NhbGUgY29uZmlndXJhdGlvblxuICAgIC8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICBmdW5jdGlvbiBsb2NhbGUoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgIH1cblxuICAgIHZhciBNU19QRVJfU0VDT05EID0gMTAwMCxcbiAgICAgICAgTVNfUEVSX01JTlVURSA9IDYwICogTVNfUEVSX1NFQ09ORCxcbiAgICAgICAgTVNfUEVSX0hPVVIgPSA2MCAqIE1TX1BFUl9NSU5VVEUsXG4gICAgICAgIE1TX1BFUl80MDBfWUVBUlMgPSAoMzY1ICogNDAwICsgOTcpICogMjQgKiBNU19QRVJfSE9VUjtcblxuICAgIC8vIGFjdHVhbCBtb2R1bG8gLSBoYW5kbGVzIG5lZ2F0aXZlIG51bWJlcnMgKGZvciBkYXRlcyBiZWZvcmUgMTk3MCk6XG4gICAgZnVuY3Rpb24gbW9kJDEoZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICAgICAgcmV0dXJuICgoZGl2aWRlbmQgJSBkaXZpc29yKSArIGRpdmlzb3IpICUgZGl2aXNvcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbFN0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSwgbSwgZCkudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXRjU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyBEYXRlLlVUQyByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5LCBtLCBkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0T2YodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWUsIHN0YXJ0T2ZEYXRlO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCAwLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSAtICh0aGlzLm1vbnRoKCkgJSAzKSxcbiAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSAodGhpcy5pc29XZWVrZGF5KCkgLSAxKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKFxuICAgICAgICAgICAgICAgICAgICB0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSxcbiAgICAgICAgICAgICAgICAgICAgTVNfUEVSX0hPVVJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWUsIHN0YXJ0T2ZEYXRlO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpICsgMSwgMCwgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCkgLSAodGhpcy5tb250aCgpICUgMykgKyAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICApIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSArIDEsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKSArIDdcbiAgICAgICAgICAgICAgICAgICAgKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkgKyA3XG4gICAgICAgICAgICAgICAgICAgICkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSArIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9XG4gICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSIC1cbiAgICAgICAgICAgICAgICAgICAgbW9kJDEoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSXG4gICAgICAgICAgICAgICAgICAgICkgLVxuICAgICAgICAgICAgICAgICAgICAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPSBNU19QRVJfTUlOVVRFIC0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPSBNU19QRVJfU0VDT05EIC0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml4KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtLnllYXIoKSxcbiAgICAgICAgICAgIG0ubW9udGgoKSxcbiAgICAgICAgICAgIG0uZGF0ZSgpLFxuICAgICAgICAgICAgbS5ob3VyKCksXG4gICAgICAgICAgICBtLm1pbnV0ZSgpLFxuICAgICAgICAgICAgbS5zZWNvbmQoKSxcbiAgICAgICAgICAgIG0ubWlsbGlzZWNvbmQoKSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMigpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dDogdGhpcy5faSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICAgICAgaXNVVEM6IHRoaXMuX2lzVVRDLFxuICAgICAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3QsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ04nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTicsIDAsIDAsICdlcmFBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ05OTicsIDAsIDAsICdlcmFBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ05OTk4nLCAwLCAwLCAnZXJhTmFtZScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk5OTicsIDAsIDAsICdlcmFOYXJyb3cnKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5JywgMV0sICd5bycsICdlcmFZZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3l5JywgMl0sIDAsICdlcmFZZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3l5eScsIDNdLCAwLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eXl5JywgNF0sIDAsICdlcmFZZWFyJyk7XG5cbiAgICBhZGRSZWdleFRva2VuKCdOJywgbWF0Y2hFcmFBYmJyKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OJywgbWF0Y2hFcmFBYmJyKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTk5OJywgbWF0Y2hFcmFOYW1lKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTk5OTicsIG1hdGNoRXJhTmFycm93KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oXG4gICAgICAgIFsnTicsICdOTicsICdOTk4nLCAnTk5OTicsICdOTk5OTiddLFxuICAgICAgICBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICB2YXIgZXJhID0gY29uZmlnLl9sb2NhbGUuZXJhc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAgICAgaWYgKGVyYSkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVyYSA9IGVyYTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEVyYSA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3knLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5eXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5bycsIG1hdGNoRXJhWWVhck9yZGluYWwpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ3knLCAneXknLCAneXl5JywgJ3l5eXknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3lvJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICBpZiAoY29uZmlnLl9sb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXgpIHtcbiAgICAgICAgICAgIG1hdGNoID0gaW5wdXQubWF0Y2goY29uZmlnLl9sb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbG9jYWxlLmVyYVllYXJPcmRpbmFsUGFyc2UpIHtcbiAgICAgICAgICAgIGFycmF5W1lFQVJdID0gY29uZmlnLl9sb2NhbGUuZXJhWWVhck9yZGluYWxQYXJzZShpbnB1dCwgbWF0Y2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuX2VyYXMgfHwgZ2V0TG9jYWxlKCdlbicpLl9lcmFzO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBob29rcyhlcmFzW2ldLnNpbmNlKS5zdGFydE9mKCdkYXknKTtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS5zaW5jZSA9IGRhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0udW50aWwgPSArSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IGhvb2tzKGVyYXNbaV0udW50aWwpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS51bnRpbCA9IGRhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJhcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzUGFyc2UoZXJhTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuZXJhcygpLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGFiYnIsXG4gICAgICAgICAgICBuYXJyb3c7XG4gICAgICAgIGVyYU5hbWUgPSBlcmFOYW1lLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuYW1lID0gZXJhc1tpXS5uYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBhYmJyID0gZXJhc1tpXS5hYmJyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBuYXJyb3cgPSBlcmFzW2ldLm5hcnJvdy50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhYmJyID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk5OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFycm93ID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFtuYW1lLCBhYmJyLCBuYXJyb3ddLmluZGV4T2YoZXJhTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhc0NvbnZlcnRZZWFyKGVyYSwgeWVhcikge1xuICAgICAgICB2YXIgZGlyID0gZXJhLnNpbmNlIDw9IGVyYS51bnRpbCA/ICsxIDogLTE7XG4gICAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBob29rcyhlcmEuc2luY2UpLnllYXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBob29rcyhlcmEuc2luY2UpLnllYXIoKSArICh5ZWFyIC0gZXJhLm9mZnNldCkgKiBkaXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFOYW1lKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYU5hcnJvdygpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhQWJicigpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5hYmJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0uYWJicjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFZZWFyKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGRpciA9IGVyYXNbaV0uc2luY2UgPD0gZXJhc1tpXS51bnRpbCA/ICsxIDogLTE7XG5cbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHx8XG4gICAgICAgICAgICAgICAgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMueWVhcigpIC0gaG9va3MoZXJhc1tpXS5zaW5jZSkueWVhcigpKSAqIGRpciArXG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0ub2Zmc2V0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcmFzTmFtZVJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX2VyYXNOYW1lUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYW1lUmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJhc0FiYnJSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzQWJiclJlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzQWJiclJlZ2V4IDogdGhpcy5fZXJhc1JlZ2V4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVyYXNOYXJyb3dSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzTmFycm93UmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYXJyb3dSZWdleCA6IHRoaXMuX2VyYXNSZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYUFiYnIoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNBYmJyUmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhTmFtZShpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZXJhc05hbWVSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFOYXJyb3coaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNOYXJyb3dSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFZZWFyT3JkaW5hbChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXggfHwgbWF0Y2hVbnNpZ25lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlRXJhc1BhcnNlKCkge1xuICAgICAgICB2YXIgYWJiclBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbmFtZVBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbmFycm93UGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5lcmFzKCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuYW1lUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYW1lKSk7XG4gICAgICAgICAgICBhYmJyUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5hYmJyKSk7XG4gICAgICAgICAgICBuYXJyb3dQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hcnJvdykpO1xuXG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFtZSkpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLmFiYnIpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYXJyb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VyYXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fZXJhc05hbWVSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG5hbWVQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9lcmFzQWJiclJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgYWJiclBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX2VyYXNOYXJyb3dSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbmFycm93UGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRycsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFxuICAgICAgICBbJ2dnZ2cnLCAnZ2dnZ2cnLCAnR0dHRycsICdHR0dHRyddLFxuICAgICAgICBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdyxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgdGhpcy5pc29XZWVrKCksXG4gICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoKSxcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICA0XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJbklTT1dlZWtZZWFyKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy5pc29XZWVrWWVhcigpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luWWVhcigpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5XZWVrWWVhcigpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLndlZWtZZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtzVGFyZ2V0O1xuICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhckRhdGEgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgICAgICB0aGlzLm1vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSk7XG4gICAgICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdxdWFydGVyJywgNyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0UXVhcnRlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbFxuICAgICAgICAgICAgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMylcbiAgICAgICAgICAgIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyAodGhpcy5tb250aCgpICUgMykpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0XG4gICAgICAgICAgICA/IGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZSB8fCBsb2NhbGUuX29yZGluYWxQYXJzZVxuICAgICAgICAgICAgOiBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsIG1hdGNoMXRvMyk7XG4gICAgYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mWWVhcihpbnB1dCkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyID1cbiAgICAgICAgICAgIE1hdGgucm91bmQoXG4gICAgICAgICAgICAgICAgKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTVcbiAgICAgICAgICAgICkgKyAxO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKGlucHV0IC0gZGF5T2ZZZWFyLCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaW51dGUnLCAxNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdtJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigncycsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsIG1hdGNoMXRvMywgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdTU1MnLCBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW4sIGdldFNldE1pbGxpc2Vjb25kO1xuICAgIGZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xuICAgIH1cblxuICAgIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAwLCAwLCAnem9uZUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFpvbmVBYmJyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIHByb3RvLmFkZCA9IGFkZDtcbiAgICBwcm90by5jYWxlbmRhciA9IGNhbGVuZGFyJDE7XG4gICAgcHJvdG8uY2xvbmUgPSBjbG9uZTtcbiAgICBwcm90by5kaWZmID0gZGlmZjtcbiAgICBwcm90by5lbmRPZiA9IGVuZE9mO1xuICAgIHByb3RvLmZvcm1hdCA9IGZvcm1hdDtcbiAgICBwcm90by5mcm9tID0gZnJvbTtcbiAgICBwcm90by5mcm9tTm93ID0gZnJvbU5vdztcbiAgICBwcm90by50byA9IHRvO1xuICAgIHByb3RvLnRvTm93ID0gdG9Ob3c7XG4gICAgcHJvdG8uZ2V0ID0gc3RyaW5nR2V0O1xuICAgIHByb3RvLmludmFsaWRBdCA9IGludmFsaWRBdDtcbiAgICBwcm90by5pc0FmdGVyID0gaXNBZnRlcjtcbiAgICBwcm90by5pc0JlZm9yZSA9IGlzQmVmb3JlO1xuICAgIHByb3RvLmlzQmV0d2VlbiA9IGlzQmV0d2VlbjtcbiAgICBwcm90by5pc1NhbWUgPSBpc1NhbWU7XG4gICAgcHJvdG8uaXNTYW1lT3JBZnRlciA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgcHJvdG8uaXNTYW1lT3JCZWZvcmUgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBwcm90by5pc1ZhbGlkID0gaXNWYWxpZCQyO1xuICAgIHByb3RvLmxhbmcgPSBsYW5nO1xuICAgIHByb3RvLmxvY2FsZSA9IGxvY2FsZTtcbiAgICBwcm90by5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcbiAgICBwcm90by5tYXggPSBwcm90b3R5cGVNYXg7XG4gICAgcHJvdG8ubWluID0gcHJvdG90eXBlTWluO1xuICAgIHByb3RvLnBhcnNpbmdGbGFncyA9IHBhcnNpbmdGbGFncztcbiAgICBwcm90by5zZXQgPSBzdHJpbmdTZXQ7XG4gICAgcHJvdG8uc3RhcnRPZiA9IHN0YXJ0T2Y7XG4gICAgcHJvdG8uc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICBwcm90by50b0FycmF5ID0gdG9BcnJheTtcbiAgICBwcm90by50b09iamVjdCA9IHRvT2JqZWN0O1xuICAgIHByb3RvLnRvRGF0ZSA9IHRvRGF0ZTtcbiAgICBwcm90by50b0lTT1N0cmluZyA9IHRvSVNPU3RyaW5nO1xuICAgIHByb3RvLmluc3BlY3QgPSBpbnNwZWN0O1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICE9IG51bGwpIHtcbiAgICAgICAgcHJvdG9bU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01vbWVudDwnICsgdGhpcy5mb3JtYXQoKSArICc+JztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcHJvdG8udG9KU09OID0gdG9KU09OO1xuICAgIHByb3RvLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgcHJvdG8udW5peCA9IHVuaXg7XG4gICAgcHJvdG8udmFsdWVPZiA9IHZhbHVlT2Y7XG4gICAgcHJvdG8uY3JlYXRpb25EYXRhID0gY3JlYXRpb25EYXRhO1xuICAgIHByb3RvLmVyYU5hbWUgPSBnZXRFcmFOYW1lO1xuICAgIHByb3RvLmVyYU5hcnJvdyA9IGdldEVyYU5hcnJvdztcbiAgICBwcm90by5lcmFBYmJyID0gZ2V0RXJhQWJicjtcbiAgICBwcm90by5lcmFZZWFyID0gZ2V0RXJhWWVhcjtcbiAgICBwcm90by55ZWFyID0gZ2V0U2V0WWVhcjtcbiAgICBwcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcbiAgICBwcm90by53ZWVrWWVhciA9IGdldFNldFdlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG4gICAgcHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcbiAgICBwcm90by5tb250aCA9IGdldFNldE1vbnRoO1xuICAgIHByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG4gICAgcHJvdG8ud2VlayA9IHByb3RvLndlZWtzID0gZ2V0U2V0V2VlaztcbiAgICBwcm90by5pc29XZWVrID0gcHJvdG8uaXNvV2Vla3MgPSBnZXRTZXRJU09XZWVrO1xuICAgIHByb3RvLndlZWtzSW5ZZWFyID0gZ2V0V2Vla3NJblllYXI7XG4gICAgcHJvdG8ud2Vla3NJbldlZWtZZWFyID0gZ2V0V2Vla3NJbldlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJbklTT1dlZWtZZWFyID0gZ2V0SVNPV2Vla3NJbklTT1dlZWtZZWFyO1xuICAgIHByb3RvLmRhdGUgPSBnZXRTZXREYXlPZk1vbnRoO1xuICAgIHByb3RvLmRheSA9IHByb3RvLmRheXMgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgcHJvdG8ud2Vla2RheSA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBwcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIHByb3RvLmRheU9mWWVhciA9IGdldFNldERheU9mWWVhcjtcbiAgICBwcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuICAgIHByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG4gICAgcHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcbiAgICBwcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuICAgIHByb3RvLnV0Y09mZnNldCA9IGdldFNldE9mZnNldDtcbiAgICBwcm90by51dGMgPSBzZXRPZmZzZXRUb1VUQztcbiAgICBwcm90by5sb2NhbCA9IHNldE9mZnNldFRvTG9jYWw7XG4gICAgcHJvdG8ucGFyc2Vab25lID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBwcm90by5pc0RTVCA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIHByb3RvLmlzTG9jYWwgPSBpc0xvY2FsO1xuICAgIHByb3RvLmlzVXRjT2Zmc2V0ID0gaXNVdGNPZmZzZXQ7XG4gICAgcHJvdG8uaXNVdGMgPSBpc1V0YztcbiAgICBwcm90by5pc1VUQyA9IGlzVXRjO1xuICAgIHByb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgcHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcbiAgICBwcm90by5kYXRlcyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJyxcbiAgICAgICAgZ2V0U2V0RGF5T2ZNb250aFxuICAgICk7XG4gICAgcHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJyxcbiAgICAgICAgZ2V0U2V0TW9udGhcbiAgICApO1xuICAgIHByb3RvLnllYXJzID0gZGVwcmVjYXRlKFxuICAgICAgICAneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsXG4gICAgICAgIGdldFNldFllYXJcbiAgICApO1xuICAgIHByb3RvLnpvbmUgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsXG4gICAgICAgIGdldFNldFpvbmVcbiAgICApO1xuICAgIHByb3RvLmlzRFNUU2hpZnRlZCA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLFxuICAgICAgICBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWRcbiAgICApO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVW5peChpbnB1dCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJblpvbmUoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90byQxLmNhbGVuZGFyID0gY2FsZW5kYXI7XG4gICAgcHJvdG8kMS5sb25nRGF0ZUZvcm1hdCA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvJDEuaW52YWxpZERhdGUgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90byQxLm9yZGluYWwgPSBvcmRpbmFsO1xuICAgIHByb3RvJDEucHJlcGFyc2UgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5wb3N0Zm9ybWF0ID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucmVsYXRpdmVUaW1lID0gcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvJDEucGFzdEZ1dHVyZSA9IHBhc3RGdXR1cmU7XG4gICAgcHJvdG8kMS5zZXQgPSBzZXQ7XG4gICAgcHJvdG8kMS5lcmFzID0gbG9jYWxlRXJhcztcbiAgICBwcm90byQxLmVyYXNQYXJzZSA9IGxvY2FsZUVyYXNQYXJzZTtcbiAgICBwcm90byQxLmVyYXNDb252ZXJ0WWVhciA9IGxvY2FsZUVyYXNDb252ZXJ0WWVhcjtcbiAgICBwcm90byQxLmVyYXNBYmJyUmVnZXggPSBlcmFzQWJiclJlZ2V4O1xuICAgIHByb3RvJDEuZXJhc05hbWVSZWdleCA9IGVyYXNOYW1lUmVnZXg7XG4gICAgcHJvdG8kMS5lcmFzTmFycm93UmVnZXggPSBlcmFzTmFycm93UmVnZXg7XG5cbiAgICBwcm90byQxLm1vbnRocyA9IGxvY2FsZU1vbnRocztcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0ID0gbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG8kMS5tb250aHNQYXJzZSA9IGxvY2FsZU1vbnRoc1BhcnNlO1xuICAgIHByb3RvJDEubW9udGhzUmVnZXggPSBtb250aHNSZWdleDtcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0UmVnZXggPSBtb250aHNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2VlayA9IGxvY2FsZVdlZWs7XG4gICAgcHJvdG8kMS5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuICAgIHByb3RvJDEud2Vla2RheXMgPSBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90byQxLndlZWtkYXlzTWluID0gbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0ID0gbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90byQxLndlZWtkYXlzUGFyc2UgPSBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5c1JlZ2V4ID0gd2Vla2RheXNSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCA9IHdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzTWluUmVnZXggPSB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgcHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8vICgpXG4gICAgLy8gKDUpXG4gICAgLy8gKGZtdCwgNSlcbiAgICAvLyAoZm10KVxuICAgIC8vICh0cnVlKVxuICAgIC8vICh0cnVlLCA1KVxuICAgIC8vICh0cnVlLCBmbXQsIDUpXG4gICAgLy8gKHRydWUsIGZtdClcbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG91dCA9IFtdO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0KGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicpO1xuICAgIH1cblxuICAgIGdldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgICAgIGVyYXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzaW5jZTogJzAwMDEtMDEtMDEnLFxuICAgICAgICAgICAgICAgIHVudGlsOiArSW5maW5pdHksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdBbm5vIERvbWluaScsXG4gICAgICAgICAgICAgICAgbmFycm93OiAnQUQnLFxuICAgICAgICAgICAgICAgIGFiYnI6ICdBRCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNpbmNlOiAnMDAwMC0xMi0zMScsXG4gICAgICAgICAgICAgICAgdW50aWw6IC1JbmZpbml0eSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0JlZm9yZSBDaHJpc3QnLFxuICAgICAgICAgICAgICAgIG5hcnJvdzogJ0JDJyxcbiAgICAgICAgICAgICAgICBhYmJyOiAnQkMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID1cbiAgICAgICAgICAgICAgICAgICAgdG9JbnQoKG51bWJlciAlIDEwMCkgLyAxMCkgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3RoJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBiID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdzdCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYiA9PT0gMlxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnbmQnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3JkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGhvb2tzLmxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsXG4gICAgICAgIGdldFNldEdsb2JhbExvY2FsZVxuICAgICk7XG4gICAgaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJyxcbiAgICAgICAgZ2V0TG9jYWxlXG4gICAgKTtcblxuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBhYnMoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCQxKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBhZGQkMShpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0JDEoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0NlaWwobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMsXG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMsXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgICAgICAgIHNlY29uZHMsXG4gICAgICAgICAgICBtaW51dGVzLFxuICAgICAgICAgICAgaG91cnMsXG4gICAgICAgICAgICB5ZWFycyxcbiAgICAgICAgICAgIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgbW9udGhzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICAgICAgc2Vjb25kcyA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgPSBzZWNvbmRzICUgNjA7XG5cbiAgICAgICAgbWludXRlcyA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICBob3VycyA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGRhdGEuaG91cnMgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgPSBkYXlzO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICAgICAgZGF0YS55ZWFycyA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyhkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiAoZGF5cyAqIDQ4MDApIC8gMTQ2MDk3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1RvRGF5cyhtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiAobW9udGhzICogMTQ2MDk3KSAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXModW5pdHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5cyxcbiAgICAgICAgICAgIG1vbnRocyxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRocztcbiAgICAgICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRocyAvIDM7XG4gICAgICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHMgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzIC8gNyArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAqIDI0ICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAqIDE0NDAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbiAgICBmdW5jdGlvbiB2YWx1ZU9mJDEoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpLFxuICAgICAgICBhc1NlY29uZHMgPSBtYWtlQXMoJ3MnKSxcbiAgICAgICAgYXNNaW51dGVzID0gbWFrZUFzKCdtJyksXG4gICAgICAgIGFzSG91cnMgPSBtYWtlQXMoJ2gnKSxcbiAgICAgICAgYXNEYXlzID0gbWFrZUFzKCdkJyksXG4gICAgICAgIGFzV2Vla3MgPSBtYWtlQXMoJ3cnKSxcbiAgICAgICAgYXNNb250aHMgPSBtYWtlQXMoJ00nKSxcbiAgICAgICAgYXNRdWFydGVycyA9IG1ha2VBcygnUScpLFxuICAgICAgICBhc1llYXJzID0gbWFrZUFzKCd5Jyk7XG5cbiAgICBmdW5jdGlvbiBjbG9uZSQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0JDIodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKSxcbiAgICAgICAgc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKSxcbiAgICAgICAgbWludXRlcyA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKSxcbiAgICAgICAgaG91cnMgPSBtYWtlR2V0dGVyKCdob3VycycpLFxuICAgICAgICBkYXlzID0gbWFrZUdldHRlcignZGF5cycpLFxuICAgICAgICBtb250aHMgPSBtYWtlR2V0dGVyKCdtb250aHMnKSxcbiAgICAgICAgeWVhcnMgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgZnVuY3Rpb24gd2Vla3MoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgICAgIHRocmVzaG9sZHMgPSB7XG4gICAgICAgICAgICBzczogNDQsIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xuICAgICAgICAgICAgczogNDUsIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgICAgICBtOiA0NSwgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgICAgICBoOiAyMiwgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgICAgICBkOiAyNiwgLy8gZGF5cyB0byBtb250aC93ZWVrXG4gICAgICAgICAgICB3OiBudWxsLCAvLyB3ZWVrcyB0byBtb250aFxuICAgICAgICAgICAgTTogMTEsIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCB0aHJlc2hvbGRzLCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpLFxuICAgICAgICAgICAgc2Vjb25kcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpLFxuICAgICAgICAgICAgbWludXRlcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpLFxuICAgICAgICAgICAgaG91cnMgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKSxcbiAgICAgICAgICAgIGRheXMgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKSxcbiAgICAgICAgICAgIG1vbnRocyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpLFxuICAgICAgICAgICAgd2Vla3MgPSByb3VuZChkdXJhdGlvbi5hcygndycpKSxcbiAgICAgICAgICAgIHllYXJzID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSksXG4gICAgICAgICAgICBhID1cbiAgICAgICAgICAgICAgICAoc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdKSB8fFxuICAgICAgICAgICAgICAgIChzZWNvbmRzIDwgdGhyZXNob2xkcy5zICYmIFsnc3MnLCBzZWNvbmRzXSkgfHxcbiAgICAgICAgICAgICAgICAobWludXRlcyA8PSAxICYmIFsnbSddKSB8fFxuICAgICAgICAgICAgICAgIChtaW51dGVzIDwgdGhyZXNob2xkcy5tICYmIFsnbW0nLCBtaW51dGVzXSkgfHxcbiAgICAgICAgICAgICAgICAoaG91cnMgPD0gMSAmJiBbJ2gnXSkgfHxcbiAgICAgICAgICAgICAgICAoaG91cnMgPCB0aHJlc2hvbGRzLmggJiYgWydoaCcsIGhvdXJzXSkgfHxcbiAgICAgICAgICAgICAgICAoZGF5cyA8PSAxICYmIFsnZCddKSB8fFxuICAgICAgICAgICAgICAgIChkYXlzIDwgdGhyZXNob2xkcy5kICYmIFsnZGQnLCBkYXlzXSk7XG5cbiAgICAgICAgaWYgKHRocmVzaG9sZHMudyAhPSBudWxsKSB7XG4gICAgICAgICAgICBhID1cbiAgICAgICAgICAgICAgICBhIHx8XG4gICAgICAgICAgICAgICAgKHdlZWtzIDw9IDEgJiYgWyd3J10pIHx8XG4gICAgICAgICAgICAgICAgKHdlZWtzIDwgdGhyZXNob2xkcy53ICYmIFsnd3cnLCB3ZWVrc10pO1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhIHx8XG4gICAgICAgICAgICAobW9udGhzIDw9IDEgJiYgWydNJ10pIHx8XG4gICAgICAgICAgICAobW9udGhzIDwgdGhyZXNob2xkcy5NICYmIFsnTU0nLCBtb250aHNdKSB8fFxuICAgICAgICAgICAgKHllYXJzIDw9IDEgJiYgWyd5J10pIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nKHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm91bmRpbmdGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgICAgICB9XG4gICAgICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICBpZiAodGhyZXNob2xkID09PSAncycpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZHMuc3MgPSBsaW1pdCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUoYXJnV2l0aFN1ZmZpeCwgYXJnVGhyZXNob2xkcykge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3aXRoU3VmZml4ID0gZmFsc2UsXG4gICAgICAgICAgICB0aCA9IHRocmVzaG9sZHMsXG4gICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdXaXRoU3VmZml4ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXJnVGhyZXNob2xkcyA9IGFyZ1dpdGhTdWZmaXg7XG4gICAgICAgICAgICBhcmdXaXRoU3VmZml4ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdXaXRoU3VmZml4ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHdpdGhTdWZmaXggPSBhcmdXaXRoU3VmZml4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXJnVGhyZXNob2xkcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoID0gT2JqZWN0LmFzc2lnbih7fSwgdGhyZXNob2xkcywgYXJnVGhyZXNob2xkcyk7XG4gICAgICAgICAgICBpZiAoYXJnVGhyZXNob2xkcy5zICE9IG51bGwgJiYgYXJnVGhyZXNob2xkcy5zcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGguc3MgPSBhcmdUaHJlc2hvbGRzLnMgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIG91dHB1dCA9IHJlbGF0aXZlVGltZSQxKHRoaXMsICF3aXRoU3VmZml4LCB0aCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWJzJDEgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIHNpZ24oeCkge1xuICAgICAgICByZXR1cm4gKHggPiAwKSAtICh4IDwgMCkgfHwgK3g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMCxcbiAgICAgICAgICAgIGRheXMgPSBhYnMkMSh0aGlzLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFicyQxKHRoaXMuX21vbnRocyksXG4gICAgICAgICAgICBtaW51dGVzLFxuICAgICAgICAgICAgaG91cnMsXG4gICAgICAgICAgICB5ZWFycyxcbiAgICAgICAgICAgIHMsXG4gICAgICAgICAgICB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCksXG4gICAgICAgICAgICB0b3RhbFNpZ24sXG4gICAgICAgICAgICB5bVNpZ24sXG4gICAgICAgICAgICBkYXlzU2lnbixcbiAgICAgICAgICAgIGhtc1NpZ247XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcblxuICAgICAgICB0b3RhbFNpZ24gPSB0b3RhbCA8IDAgPyAnLScgOiAnJztcbiAgICAgICAgeW1TaWduID0gc2lnbih0aGlzLl9tb250aHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIGhtc1NpZ24gPSBzaWduKHRoaXMuX21pbGxpc2Vjb25kcykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRvdGFsU2lnbiArXG4gICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgKHllYXJzID8geW1TaWduICsgeWVhcnMgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgKG1vbnRocyA/IHltU2lnbiArIG1vbnRocyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoZGF5cyA/IGRheXNTaWduICsgZGF5cyArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoaG91cnMgfHwgbWludXRlcyB8fCBzZWNvbmRzID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChob3VycyA/IGhtc1NpZ24gKyBob3VycyArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobWludXRlcyA/IGhtc1NpZ24gKyBtaW51dGVzICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChzZWNvbmRzID8gaG1zU2lnbiArIHMgKyAnUycgOiAnJylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDIuaXNWYWxpZCA9IGlzVmFsaWQkMTtcbiAgICBwcm90byQyLmFicyA9IGFicztcbiAgICBwcm90byQyLmFkZCA9IGFkZCQxO1xuICAgIHByb3RvJDIuc3VidHJhY3QgPSBzdWJ0cmFjdCQxO1xuICAgIHByb3RvJDIuYXMgPSBhcztcbiAgICBwcm90byQyLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5hc1NlY29uZHMgPSBhc1NlY29uZHM7XG4gICAgcHJvdG8kMi5hc01pbnV0ZXMgPSBhc01pbnV0ZXM7XG4gICAgcHJvdG8kMi5hc0hvdXJzID0gYXNIb3VycztcbiAgICBwcm90byQyLmFzRGF5cyA9IGFzRGF5cztcbiAgICBwcm90byQyLmFzV2Vla3MgPSBhc1dlZWtzO1xuICAgIHByb3RvJDIuYXNNb250aHMgPSBhc01vbnRocztcbiAgICBwcm90byQyLmFzUXVhcnRlcnMgPSBhc1F1YXJ0ZXJzO1xuICAgIHByb3RvJDIuYXNZZWFycyA9IGFzWWVhcnM7XG4gICAgcHJvdG8kMi52YWx1ZU9mID0gdmFsdWVPZiQxO1xuICAgIHByb3RvJDIuX2J1YmJsZSA9IGJ1YmJsZTtcbiAgICBwcm90byQyLmNsb25lID0gY2xvbmUkMTtcbiAgICBwcm90byQyLmdldCA9IGdldCQyO1xuICAgIHByb3RvJDIubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuc2Vjb25kcyA9IHNlY29uZHM7XG4gICAgcHJvdG8kMi5taW51dGVzID0gbWludXRlcztcbiAgICBwcm90byQyLmhvdXJzID0gaG91cnM7XG4gICAgcHJvdG8kMi5kYXlzID0gZGF5cztcbiAgICBwcm90byQyLndlZWtzID0gd2Vla3M7XG4gICAgcHJvdG8kMi5tb250aHMgPSBtb250aHM7XG4gICAgcHJvdG8kMi55ZWFycyA9IHllYXJzO1xuICAgIHByb3RvJDIuaHVtYW5pemUgPSBodW1hbml6ZTtcbiAgICBwcm90byQyLnRvSVNPU3RyaW5nID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvU3RyaW5nID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvSlNPTiA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi5sb2NhbGUgPSBsb2NhbGU7XG4gICAgcHJvdG8kMi5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcblxuICAgIHByb3RvJDIudG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsXG4gICAgICAgIHRvSVNPU3RyaW5nJDFcbiAgICApO1xuICAgIHByb3RvJDIubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyEgbW9tZW50LmpzXG5cbiAgICBob29rcy52ZXJzaW9uID0gJzIuMjkuNCc7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xuXG4gICAgaG9va3MuZm4gPSBwcm90bztcbiAgICBob29rcy5taW4gPSBtaW47XG4gICAgaG9va3MubWF4ID0gbWF4O1xuICAgIGhvb2tzLm5vdyA9IG5vdztcbiAgICBob29rcy51dGMgPSBjcmVhdGVVVEM7XG4gICAgaG9va3MudW5peCA9IGNyZWF0ZVVuaXg7XG4gICAgaG9va3MubW9udGhzID0gbGlzdE1vbnRocztcbiAgICBob29rcy5pc0RhdGUgPSBpc0RhdGU7XG4gICAgaG9va3MubG9jYWxlID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIGhvb2tzLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkO1xuICAgIGhvb2tzLmR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb247XG4gICAgaG9va3MuaXNNb21lbnQgPSBpc01vbWVudDtcbiAgICBob29rcy53ZWVrZGF5cyA9IGxpc3RXZWVrZGF5cztcbiAgICBob29rcy5wYXJzZVpvbmUgPSBjcmVhdGVJblpvbmU7XG4gICAgaG9va3MubG9jYWxlRGF0YSA9IGdldExvY2FsZTtcbiAgICBob29rcy5pc0R1cmF0aW9uID0gaXNEdXJhdGlvbjtcbiAgICBob29rcy5tb250aHNTaG9ydCA9IGxpc3RNb250aHNTaG9ydDtcbiAgICBob29rcy53ZWVrZGF5c01pbiA9IGxpc3RXZWVrZGF5c01pbjtcbiAgICBob29rcy5kZWZpbmVMb2NhbGUgPSBkZWZpbmVMb2NhbGU7XG4gICAgaG9va3MudXBkYXRlTG9jYWxlID0gdXBkYXRlTG9jYWxlO1xuICAgIGhvb2tzLmxvY2FsZXMgPSBsaXN0TG9jYWxlcztcbiAgICBob29rcy53ZWVrZGF5c1Nob3J0ID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgaG9va3Mubm9ybWFsaXplVW5pdHMgPSBub3JtYWxpemVVbml0cztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbiAgICBob29rcy5jYWxlbmRhckZvcm1hdCA9IGdldENhbGVuZGFyRm9ybWF0O1xuICAgIGhvb2tzLnByb3RvdHlwZSA9IHByb3RvO1xuXG4gICAgLy8gY3VycmVudGx5IEhUTUw1IGlucHV0IHR5cGUgb25seSBzdXBwb3J0cyAyNC1ob3VyIGZvcm1hdHNcbiAgICBob29rcy5IVE1MNV9GTVQgPSB7XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMOiAnWVlZWS1NTS1ERFRISDptbScsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9TRUNPTkRTOiAnWVlZWS1NTS1ERFRISDptbTpzcycsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX01TOiAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1MnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgREFURTogJ1lZWVktTU0tREQnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGVcIiAvPlxuICAgICAgICBUSU1FOiAnSEg6bW0nLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiAvPlxuICAgICAgICBUSU1FX1NFQ09ORFM6ICdISDptbTpzcycsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgVElNRV9NUzogJ0hIOm1tOnNzLlNTUycsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIFdFRUs6ICdHR0dHLVtXXVdXJywgLy8gPGlucHV0IHR5cGU9XCJ3ZWVrXCIgLz5cbiAgICAgICAgTU9OVEg6ICdZWVlZLU1NJywgLy8gPGlucHV0IHR5cGU9XCJtb250aFwiIC8+XG4gICAgfTtcblxuICAgIHJldHVybiBob29rcztcblxufSkpKTtcbiJdLCJuYW1lcyI6WyJnbG9iYWwiLCJmYWN0b3J5IiwiZXhwb3J0cyIsIm1vZHVsZSIsImRlZmluZSIsImFtZCIsIm1vbWVudCIsImhvb2tDYWxsYmFjayIsImhvb2tzIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJzZXRIb29rQ2FsbGJhY2siLCJjYWxsYmFjayIsImlzQXJyYXkiLCJpbnB1dCIsIkFycmF5IiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaXNPYmplY3QiLCJoYXNPd25Qcm9wIiwiYSIsImIiLCJoYXNPd25Qcm9wZXJ0eSIsImlzT2JqZWN0RW1wdHkiLCJvYmoiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwibGVuZ3RoIiwiayIsImlzVW5kZWZpbmVkIiwiaXNOdW1iZXIiLCJpc0RhdGUiLCJEYXRlIiwibWFwIiwiYXJyIiwiZm4iLCJyZXMiLCJpIiwiYXJyTGVuIiwicHVzaCIsImV4dGVuZCIsInZhbHVlT2YiLCJjcmVhdGVVVEMiLCJmb3JtYXQiLCJsb2NhbGUiLCJzdHJpY3QiLCJjcmVhdGVMb2NhbE9yVVRDIiwidXRjIiwiZGVmYXVsdFBhcnNpbmdGbGFncyIsImVtcHR5IiwidW51c2VkVG9rZW5zIiwidW51c2VkSW5wdXQiLCJvdmVyZmxvdyIsImNoYXJzTGVmdE92ZXIiLCJudWxsSW5wdXQiLCJpbnZhbGlkRXJhIiwiaW52YWxpZE1vbnRoIiwiaW52YWxpZEZvcm1hdCIsInVzZXJJbnZhbGlkYXRlZCIsImlzbyIsInBhcnNlZERhdGVQYXJ0cyIsImVyYSIsIm1lcmlkaWVtIiwicmZjMjgyMiIsIndlZWtkYXlNaXNtYXRjaCIsImdldFBhcnNpbmdGbGFncyIsIm0iLCJfcGYiLCJzb21lIiwiZnVuIiwidCIsImxlbiIsImlzVmFsaWQiLCJfaXNWYWxpZCIsImZsYWdzIiwicGFyc2VkUGFydHMiLCJpc05vd1ZhbGlkIiwiaXNOYU4iLCJfZCIsImdldFRpbWUiLCJpbnZhbGlkV2Vla2RheSIsIl9zdHJpY3QiLCJiaWdIb3VyIiwidW5kZWZpbmVkIiwiaXNGcm96ZW4iLCJjcmVhdGVJbnZhbGlkIiwiTmFOIiwibW9tZW50UHJvcGVydGllcyIsInVwZGF0ZUluUHJvZ3Jlc3MiLCJjb3B5Q29uZmlnIiwidG8iLCJmcm9tIiwicHJvcCIsInZhbCIsIm1vbWVudFByb3BlcnRpZXNMZW4iLCJfaXNBTW9tZW50T2JqZWN0IiwiX2kiLCJfZiIsIl9sIiwiX3R6bSIsIl9pc1VUQyIsIl9vZmZzZXQiLCJfbG9jYWxlIiwiTW9tZW50IiwiY29uZmlnIiwidXBkYXRlT2Zmc2V0IiwiaXNNb21lbnQiLCJ3YXJuIiwibXNnIiwic3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzIiwiY29uc29sZSIsImRlcHJlY2F0ZSIsImZpcnN0VGltZSIsImRlcHJlY2F0aW9uSGFuZGxlciIsImFyZ3MiLCJhcmciLCJrZXkiLCJhcmdMZW4iLCJzbGljZSIsImpvaW4iLCJFcnJvciIsInN0YWNrIiwiZGVwcmVjYXRpb25zIiwiZGVwcmVjYXRlU2ltcGxlIiwibmFtZSIsImlzRnVuY3Rpb24iLCJGdW5jdGlvbiIsInNldCIsIl9jb25maWciLCJfZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQiLCJSZWdFeHAiLCJfZGF5T2ZNb250aE9yZGluYWxQYXJzZSIsInNvdXJjZSIsIl9vcmRpbmFsUGFyc2UiLCJtZXJnZUNvbmZpZ3MiLCJwYXJlbnRDb25maWciLCJjaGlsZENvbmZpZyIsIkxvY2FsZSIsImtleXMiLCJkZWZhdWx0Q2FsZW5kYXIiLCJzYW1lRGF5IiwibmV4dERheSIsIm5leHRXZWVrIiwibGFzdERheSIsImxhc3RXZWVrIiwic2FtZUVsc2UiLCJjYWxlbmRhciIsIm1vbSIsIm5vdyIsIm91dHB1dCIsIl9jYWxlbmRhciIsInplcm9GaWxsIiwibnVtYmVyIiwidGFyZ2V0TGVuZ3RoIiwiZm9yY2VTaWduIiwiYWJzTnVtYmVyIiwiTWF0aCIsImFicyIsInplcm9zVG9GaWxsIiwic2lnbiIsInBvdyIsIm1heCIsInN1YnN0ciIsImZvcm1hdHRpbmdUb2tlbnMiLCJsb2NhbEZvcm1hdHRpbmdUb2tlbnMiLCJmb3JtYXRGdW5jdGlvbnMiLCJmb3JtYXRUb2tlbkZ1bmN0aW9ucyIsImFkZEZvcm1hdFRva2VuIiwidG9rZW4iLCJwYWRkZWQiLCJvcmRpbmFsIiwiZnVuYyIsImxvY2FsZURhdGEiLCJyZW1vdmVGb3JtYXR0aW5nVG9rZW5zIiwibWF0Y2giLCJyZXBsYWNlIiwibWFrZUZvcm1hdEZ1bmN0aW9uIiwiYXJyYXkiLCJmb3JtYXRNb21lbnQiLCJpbnZhbGlkRGF0ZSIsImV4cGFuZEZvcm1hdCIsInJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyIsImxvbmdEYXRlRm9ybWF0IiwibGFzdEluZGV4IiwidGVzdCIsImRlZmF1bHRMb25nRGF0ZUZvcm1hdCIsIkxUUyIsIkxUIiwiTCIsIkxMIiwiTExMIiwiTExMTCIsIl9sb25nRGF0ZUZvcm1hdCIsImZvcm1hdFVwcGVyIiwidG9VcHBlckNhc2UiLCJ0b2siLCJkZWZhdWx0SW52YWxpZERhdGUiLCJfaW52YWxpZERhdGUiLCJkZWZhdWx0T3JkaW5hbCIsImRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlIiwiX29yZGluYWwiLCJkZWZhdWx0UmVsYXRpdmVUaW1lIiwiZnV0dXJlIiwicGFzdCIsInMiLCJzcyIsIm1tIiwiaCIsImhoIiwiZCIsImRkIiwidyIsInd3IiwiTSIsIk1NIiwieSIsInl5IiwicmVsYXRpdmVUaW1lIiwid2l0aG91dFN1ZmZpeCIsInN0cmluZyIsImlzRnV0dXJlIiwiX3JlbGF0aXZlVGltZSIsInBhc3RGdXR1cmUiLCJkaWZmIiwiYWxpYXNlcyIsImFkZFVuaXRBbGlhcyIsInVuaXQiLCJzaG9ydGhhbmQiLCJsb3dlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsIm5vcm1hbGl6ZVVuaXRzIiwidW5pdHMiLCJub3JtYWxpemVPYmplY3RVbml0cyIsImlucHV0T2JqZWN0Iiwibm9ybWFsaXplZElucHV0Iiwibm9ybWFsaXplZFByb3AiLCJwcmlvcml0aWVzIiwiYWRkVW5pdFByaW9yaXR5IiwicHJpb3JpdHkiLCJnZXRQcmlvcml0aXplZFVuaXRzIiwidW5pdHNPYmoiLCJ1Iiwic29ydCIsImlzTGVhcFllYXIiLCJ5ZWFyIiwiYWJzRmxvb3IiLCJjZWlsIiwiZmxvb3IiLCJ0b0ludCIsImFyZ3VtZW50Rm9yQ29lcmNpb24iLCJjb2VyY2VkTnVtYmVyIiwidmFsdWUiLCJpc0Zpbml0ZSIsIm1ha2VHZXRTZXQiLCJrZWVwVGltZSIsInNldCQxIiwiZ2V0IiwibW9udGgiLCJkYXRlIiwiZGF5c0luTW9udGgiLCJzdHJpbmdHZXQiLCJzdHJpbmdTZXQiLCJwcmlvcml0aXplZCIsInByaW9yaXRpemVkTGVuIiwibWF0Y2gxIiwibWF0Y2gyIiwibWF0Y2gzIiwibWF0Y2g0IiwibWF0Y2g2IiwibWF0Y2gxdG8yIiwibWF0Y2gzdG80IiwibWF0Y2g1dG82IiwibWF0Y2gxdG8zIiwibWF0Y2gxdG80IiwibWF0Y2gxdG82IiwibWF0Y2hVbnNpZ25lZCIsIm1hdGNoU2lnbmVkIiwibWF0Y2hPZmZzZXQiLCJtYXRjaFNob3J0T2Zmc2V0IiwibWF0Y2hUaW1lc3RhbXAiLCJtYXRjaFdvcmQiLCJyZWdleGVzIiwiYWRkUmVnZXhUb2tlbiIsInJlZ2V4Iiwic3RyaWN0UmVnZXgiLCJpc1N0cmljdCIsImdldFBhcnNlUmVnZXhGb3JUb2tlbiIsInVuZXNjYXBlRm9ybWF0IiwicmVnZXhFc2NhcGUiLCJtYXRjaGVkIiwicDEiLCJwMiIsInAzIiwicDQiLCJ0b2tlbnMiLCJhZGRQYXJzZVRva2VuIiwidG9rZW5MZW4iLCJhZGRXZWVrUGFyc2VUb2tlbiIsIl93IiwiYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4iLCJfYSIsIllFQVIiLCJNT05USCIsIkRBVEUiLCJIT1VSIiwiTUlOVVRFIiwiU0VDT05EIiwiTUlMTElTRUNPTkQiLCJXRUVLIiwiV0VFS0RBWSIsIm1vZCIsIm4iLCJ4IiwiaW5kZXhPZiIsIm8iLCJtb2RNb250aCIsIm1vbnRoc1Nob3J0IiwibW9udGhzIiwibW9udGhzU2hvcnRSZWdleCIsIm1vbnRoc1JlZ2V4IiwibW9udGhzUGFyc2UiLCJkZWZhdWx0TG9jYWxlTW9udGhzIiwic3BsaXQiLCJkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQiLCJNT05USFNfSU5fRk9STUFUIiwiZGVmYXVsdE1vbnRoc1Nob3J0UmVnZXgiLCJkZWZhdWx0TW9udGhzUmVnZXgiLCJsb2NhbGVNb250aHMiLCJfbW9udGhzIiwiaXNGb3JtYXQiLCJsb2NhbGVNb250aHNTaG9ydCIsIl9tb250aHNTaG9ydCIsImhhbmRsZVN0cmljdFBhcnNlIiwibW9udGhOYW1lIiwiaWkiLCJsbGMiLCJ0b0xvY2FsZUxvd2VyQ2FzZSIsIl9tb250aHNQYXJzZSIsIl9sb25nTW9udGhzUGFyc2UiLCJfc2hvcnRNb250aHNQYXJzZSIsImxvY2FsZU1vbnRoc1BhcnNlIiwiX21vbnRoc1BhcnNlRXhhY3QiLCJzZXRNb250aCIsImRheU9mTW9udGgiLCJtaW4iLCJnZXRTZXRNb250aCIsImdldERheXNJbk1vbnRoIiwiY29tcHV0ZU1vbnRoc1BhcnNlIiwiX21vbnRoc1Nob3J0U3RyaWN0UmVnZXgiLCJfbW9udGhzU2hvcnRSZWdleCIsIl9tb250aHNTdHJpY3RSZWdleCIsIl9tb250aHNSZWdleCIsImNtcExlblJldiIsInNob3J0UGllY2VzIiwibG9uZ1BpZWNlcyIsIm1peGVkUGllY2VzIiwicGFyc2VUd29EaWdpdFllYXIiLCJwYXJzZUludCIsImRheXNJblllYXIiLCJnZXRTZXRZZWFyIiwiZ2V0SXNMZWFwWWVhciIsImNyZWF0ZURhdGUiLCJtcyIsImdldEZ1bGxZZWFyIiwic2V0RnVsbFllYXIiLCJjcmVhdGVVVENEYXRlIiwiVVRDIiwiZ2V0VVRDRnVsbFllYXIiLCJzZXRVVENGdWxsWWVhciIsImZpcnN0V2Vla09mZnNldCIsImRvdyIsImRveSIsImZ3ZCIsImZ3ZGx3IiwiZ2V0VVRDRGF5IiwiZGF5T2ZZZWFyRnJvbVdlZWtzIiwid2VlayIsIndlZWtkYXkiLCJsb2NhbFdlZWtkYXkiLCJ3ZWVrT2Zmc2V0IiwiZGF5T2ZZZWFyIiwicmVzWWVhciIsInJlc0RheU9mWWVhciIsIndlZWtPZlllYXIiLCJyZXNXZWVrIiwid2Vla3NJblllYXIiLCJ3ZWVrT2Zmc2V0TmV4dCIsImxvY2FsZVdlZWsiLCJfd2VlayIsImRlZmF1bHRMb2NhbGVXZWVrIiwibG9jYWxlRmlyc3REYXlPZldlZWsiLCJsb2NhbGVGaXJzdERheU9mWWVhciIsImdldFNldFdlZWsiLCJhZGQiLCJnZXRTZXRJU09XZWVrIiwid2Vla2RheXNNaW4iLCJ3ZWVrZGF5c1Nob3J0Iiwid2Vla2RheXMiLCJ3ZWVrZGF5c01pblJlZ2V4Iiwid2Vla2RheXNTaG9ydFJlZ2V4Iiwid2Vla2RheXNSZWdleCIsIndlZWtkYXlzUGFyc2UiLCJwYXJzZVdlZWtkYXkiLCJwYXJzZUlzb1dlZWtkYXkiLCJzaGlmdFdlZWtkYXlzIiwid3MiLCJjb25jYXQiLCJkZWZhdWx0TG9jYWxlV2Vla2RheXMiLCJkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCIsImRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiIsImRlZmF1bHRXZWVrZGF5c1JlZ2V4IiwiZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCIsImRlZmF1bHRXZWVrZGF5c01pblJlZ2V4IiwibG9jYWxlV2Vla2RheXMiLCJfd2Vla2RheXMiLCJkYXkiLCJsb2NhbGVXZWVrZGF5c1Nob3J0IiwiX3dlZWtkYXlzU2hvcnQiLCJsb2NhbGVXZWVrZGF5c01pbiIsIl93ZWVrZGF5c01pbiIsImhhbmRsZVN0cmljdFBhcnNlJDEiLCJ3ZWVrZGF5TmFtZSIsIl93ZWVrZGF5c1BhcnNlIiwiX3Nob3J0V2Vla2RheXNQYXJzZSIsIl9taW5XZWVrZGF5c1BhcnNlIiwibG9jYWxlV2Vla2RheXNQYXJzZSIsIl93ZWVrZGF5c1BhcnNlRXhhY3QiLCJfZnVsbFdlZWtkYXlzUGFyc2UiLCJnZXRTZXREYXlPZldlZWsiLCJnZXREYXkiLCJnZXRTZXRMb2NhbGVEYXlPZldlZWsiLCJnZXRTZXRJU09EYXlPZldlZWsiLCJjb21wdXRlV2Vla2RheXNQYXJzZSIsIl93ZWVrZGF5c1N0cmljdFJlZ2V4IiwiX3dlZWtkYXlzUmVnZXgiLCJfd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IiwiX3dlZWtkYXlzU2hvcnRSZWdleCIsIl93ZWVrZGF5c01pblN0cmljdFJlZ2V4IiwiX3dlZWtkYXlzTWluUmVnZXgiLCJtaW5QaWVjZXMiLCJtaW5wIiwic2hvcnRwIiwibG9uZ3AiLCJoRm9ybWF0IiwiaG91cnMiLCJrRm9ybWF0IiwibWludXRlcyIsInNlY29uZHMiLCJsb3dlcmNhc2UiLCJtYXRjaE1lcmlkaWVtIiwiX21lcmlkaWVtUGFyc2UiLCJrSW5wdXQiLCJfaXNQbSIsImlzUE0iLCJfbWVyaWRpZW0iLCJwb3MiLCJwb3MxIiwicG9zMiIsImxvY2FsZUlzUE0iLCJjaGFyQXQiLCJkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSIsImdldFNldEhvdXIiLCJsb2NhbGVNZXJpZGllbSIsImlzTG93ZXIiLCJiYXNlQ29uZmlnIiwiZGF5T2ZNb250aE9yZGluYWxQYXJzZSIsIm1lcmlkaWVtUGFyc2UiLCJsb2NhbGVzIiwibG9jYWxlRmFtaWxpZXMiLCJnbG9iYWxMb2NhbGUiLCJjb21tb25QcmVmaXgiLCJhcnIxIiwiYXJyMiIsIm1pbmwiLCJub3JtYWxpemVMb2NhbGUiLCJjaG9vc2VMb2NhbGUiLCJuYW1lcyIsImoiLCJuZXh0IiwibG9hZExvY2FsZSIsImlzTG9jYWxlTmFtZVNhbmUiLCJvbGRMb2NhbGUiLCJhbGlhc2VkUmVxdWlyZSIsIl9hYmJyIiwicmVxdWlyZSIsImdldFNldEdsb2JhbExvY2FsZSIsImUiLCJ2YWx1ZXMiLCJkYXRhIiwiZ2V0TG9jYWxlIiwiZGVmaW5lTG9jYWxlIiwiYWJiciIsInBhcmVudExvY2FsZSIsImZvckVhY2giLCJ1cGRhdGVMb2NhbGUiLCJ0bXBMb2NhbGUiLCJsaXN0TG9jYWxlcyIsImNoZWNrT3ZlcmZsb3ciLCJfb3ZlcmZsb3dEYXlPZlllYXIiLCJfb3ZlcmZsb3dXZWVrcyIsIl9vdmVyZmxvd1dlZWtkYXkiLCJleHRlbmRlZElzb1JlZ2V4IiwiYmFzaWNJc29SZWdleCIsInR6UmVnZXgiLCJpc29EYXRlcyIsImlzb1RpbWVzIiwiYXNwTmV0SnNvblJlZ2V4Iiwib2JzT2Zmc2V0cyIsIlVUIiwiR01UIiwiRURUIiwiRVNUIiwiQ0RUIiwiQ1NUIiwiTURUIiwiTVNUIiwiUERUIiwiUFNUIiwiY29uZmlnRnJvbUlTTyIsImwiLCJleGVjIiwiYWxsb3dUaW1lIiwiZGF0ZUZvcm1hdCIsInRpbWVGb3JtYXQiLCJ0ekZvcm1hdCIsImlzb0RhdGVzTGVuIiwiaXNvVGltZXNMZW4iLCJjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0IiwiZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyIsInllYXJTdHIiLCJtb250aFN0ciIsImRheVN0ciIsImhvdXJTdHIiLCJtaW51dGVTdHIiLCJzZWNvbmRTdHIiLCJyZXN1bHQiLCJ1bnRydW5jYXRlWWVhciIsInByZXByb2Nlc3NSRkMyODIyIiwiY2hlY2tXZWVrZGF5Iiwid2Vla2RheVN0ciIsInBhcnNlZElucHV0Iiwid2Vla2RheVByb3ZpZGVkIiwid2Vla2RheUFjdHVhbCIsImNhbGN1bGF0ZU9mZnNldCIsIm9ic09mZnNldCIsIm1pbGl0YXJ5T2Zmc2V0IiwibnVtT2Zmc2V0IiwiaG0iLCJjb25maWdGcm9tUkZDMjgyMiIsInBhcnNlZEFycmF5Iiwic2V0VVRDTWludXRlcyIsImdldFVUQ01pbnV0ZXMiLCJjb25maWdGcm9tU3RyaW5nIiwiY3JlYXRlRnJvbUlucHV0RmFsbGJhY2siLCJfdXNlVVRDIiwiZGVmYXVsdHMiLCJjIiwiY3VycmVudERhdGVBcnJheSIsIm5vd1ZhbHVlIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwiY29uZmlnRnJvbUFycmF5IiwiY3VycmVudERhdGUiLCJleHBlY3RlZFdlZWtkYXkiLCJ5ZWFyVG9Vc2UiLCJkYXlPZlllYXJGcm9tV2Vla0luZm8iLCJfZGF5T2ZZZWFyIiwiX25leHREYXkiLCJ3ZWVrWWVhciIsInRlbXAiLCJ3ZWVrZGF5T3ZlcmZsb3ciLCJjdXJXZWVrIiwiR0ciLCJXIiwiRSIsImNyZWF0ZUxvY2FsIiwiZ2ciLCJJU09fODYwMSIsIlJGQ18yODIyIiwic2tpcHBlZCIsInN0cmluZ0xlbmd0aCIsInRvdGFsUGFyc2VkSW5wdXRMZW5ndGgiLCJtZXJpZGllbUZpeFdyYXAiLCJlcmFzQ29udmVydFllYXIiLCJob3VyIiwiaXNQbSIsIm1lcmlkaWVtSG91ciIsImNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheSIsInRlbXBDb25maWciLCJiZXN0TW9tZW50Iiwic2NvcmVUb0JlYXQiLCJjdXJyZW50U2NvcmUiLCJ2YWxpZEZvcm1hdEZvdW5kIiwiYmVzdEZvcm1hdElzVmFsaWQiLCJjb25maWdmTGVuIiwic2NvcmUiLCJjb25maWdGcm9tT2JqZWN0IiwiZGF5T3JEYXRlIiwibWludXRlIiwic2Vjb25kIiwibWlsbGlzZWNvbmQiLCJjcmVhdGVGcm9tQ29uZmlnIiwicHJlcGFyZUNvbmZpZyIsInByZXBhcnNlIiwiY29uZmlnRnJvbUlucHV0IiwiaXNVVEMiLCJwcm90b3R5cGVNaW4iLCJvdGhlciIsInByb3RvdHlwZU1heCIsInBpY2tCeSIsIm1vbWVudHMiLCJvcmRlcmluZyIsImlzRHVyYXRpb25WYWxpZCIsInVuaXRIYXNEZWNpbWFsIiwib3JkZXJMZW4iLCJwYXJzZUZsb2F0IiwiaXNWYWxpZCQxIiwiY3JlYXRlSW52YWxpZCQxIiwiY3JlYXRlRHVyYXRpb24iLCJEdXJhdGlvbiIsImR1cmF0aW9uIiwieWVhcnMiLCJxdWFydGVycyIsInF1YXJ0ZXIiLCJ3ZWVrcyIsImlzb1dlZWsiLCJkYXlzIiwibWlsbGlzZWNvbmRzIiwiX21pbGxpc2Vjb25kcyIsIl9kYXlzIiwiX2RhdGEiLCJfYnViYmxlIiwiaXNEdXJhdGlvbiIsImFic1JvdW5kIiwicm91bmQiLCJjb21wYXJlQXJyYXlzIiwiYXJyYXkxIiwiYXJyYXkyIiwiZG9udENvbnZlcnQiLCJsZW5ndGhEaWZmIiwiZGlmZnMiLCJvZmZzZXQiLCJzZXBhcmF0b3IiLCJ1dGNPZmZzZXQiLCJvZmZzZXRGcm9tU3RyaW5nIiwiY2h1bmtPZmZzZXQiLCJtYXRjaGVyIiwibWF0Y2hlcyIsImNodW5rIiwicGFydHMiLCJjbG9uZVdpdGhPZmZzZXQiLCJtb2RlbCIsImNsb25lIiwic2V0VGltZSIsImxvY2FsIiwiZ2V0RGF0ZU9mZnNldCIsImdldFRpbWV6b25lT2Zmc2V0IiwiZ2V0U2V0T2Zmc2V0Iiwia2VlcExvY2FsVGltZSIsImtlZXBNaW51dGVzIiwibG9jYWxBZGp1c3QiLCJfY2hhbmdlSW5Qcm9ncmVzcyIsImFkZFN1YnRyYWN0IiwiZ2V0U2V0Wm9uZSIsInNldE9mZnNldFRvVVRDIiwic2V0T2Zmc2V0VG9Mb2NhbCIsInN1YnRyYWN0Iiwic2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQiLCJ0Wm9uZSIsImhhc0FsaWduZWRIb3VyT2Zmc2V0IiwiaXNEYXlsaWdodFNhdmluZ1RpbWUiLCJpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQiLCJfaXNEU1RTaGlmdGVkIiwidG9BcnJheSIsImlzTG9jYWwiLCJpc1V0Y09mZnNldCIsImlzVXRjIiwiYXNwTmV0UmVnZXgiLCJpc29SZWdleCIsInJldCIsImRpZmZSZXMiLCJwYXJzZUlzbyIsIm1vbWVudHNEaWZmZXJlbmNlIiwiaW52YWxpZCIsImlucCIsInBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UiLCJiYXNlIiwiaXNBZnRlciIsImlzQmVmb3JlIiwiY3JlYXRlQWRkZXIiLCJkaXJlY3Rpb24iLCJwZXJpb2QiLCJkdXIiLCJ0bXAiLCJpc0FkZGluZyIsImlzU3RyaW5nIiwiU3RyaW5nIiwiaXNNb21lbnRJbnB1dCIsImlzTnVtYmVyT3JTdHJpbmdBcnJheSIsImlzTW9tZW50SW5wdXRPYmplY3QiLCJvYmplY3RUZXN0IiwicHJvcGVydHlUZXN0IiwicHJvcGVydGllcyIsInByb3BlcnR5IiwicHJvcGVydHlMZW4iLCJhcnJheVRlc3QiLCJkYXRhVHlwZVRlc3QiLCJmaWx0ZXIiLCJpdGVtIiwiaXNDYWxlbmRhclNwZWMiLCJnZXRDYWxlbmRhckZvcm1hdCIsIm15TW9tZW50IiwiY2FsZW5kYXIkMSIsInRpbWUiLCJmb3JtYXRzIiwic29kIiwic3RhcnRPZiIsImNhbGVuZGFyRm9ybWF0IiwibG9jYWxJbnB1dCIsImVuZE9mIiwiaXNCZXR3ZWVuIiwiaW5jbHVzaXZpdHkiLCJsb2NhbEZyb20iLCJsb2NhbFRvIiwiaXNTYW1lIiwiaW5wdXRNcyIsImlzU2FtZU9yQWZ0ZXIiLCJpc1NhbWVPckJlZm9yZSIsImFzRmxvYXQiLCJ0aGF0Iiwiem9uZURlbHRhIiwibW9udGhEaWZmIiwid2hvbGVNb250aERpZmYiLCJhbmNob3IiLCJhbmNob3IyIiwiYWRqdXN0IiwiZGVmYXVsdEZvcm1hdCIsImRlZmF1bHRGb3JtYXRVdGMiLCJ0b0lTT1N0cmluZyIsImtlZXBPZmZzZXQiLCJ0b0RhdGUiLCJpbnNwZWN0Iiwiem9uZSIsInByZWZpeCIsImRhdGV0aW1lIiwic3VmZml4IiwiaW5wdXRTdHJpbmciLCJwb3N0Zm9ybWF0IiwiaHVtYW5pemUiLCJmcm9tTm93IiwidG9Ob3ciLCJuZXdMb2NhbGVEYXRhIiwibGFuZyIsIk1TX1BFUl9TRUNPTkQiLCJNU19QRVJfTUlOVVRFIiwiTVNfUEVSX0hPVVIiLCJNU19QRVJfNDAwX1lFQVJTIiwibW9kJDEiLCJkaXZpZGVuZCIsImRpdmlzb3IiLCJsb2NhbFN0YXJ0T2ZEYXRlIiwidXRjU3RhcnRPZkRhdGUiLCJzdGFydE9mRGF0ZSIsImlzb1dlZWtkYXkiLCJ1bml4IiwidG9PYmplY3QiLCJ0b0pTT04iLCJpc1ZhbGlkJDIiLCJwYXJzaW5nRmxhZ3MiLCJpbnZhbGlkQXQiLCJjcmVhdGlvbkRhdGEiLCJtYXRjaEVyYUFiYnIiLCJtYXRjaEVyYU5hbWUiLCJtYXRjaEVyYU5hcnJvdyIsImVyYXNQYXJzZSIsIm1hdGNoRXJhWWVhck9yZGluYWwiLCJfZXJhWWVhck9yZGluYWxSZWdleCIsImVyYVllYXJPcmRpbmFsUGFyc2UiLCJsb2NhbGVFcmFzIiwiZXJhcyIsIl9lcmFzIiwic2luY2UiLCJ1bnRpbCIsIkluZmluaXR5IiwibG9jYWxlRXJhc1BhcnNlIiwiZXJhTmFtZSIsIm5hcnJvdyIsImxvY2FsZUVyYXNDb252ZXJ0WWVhciIsImRpciIsImdldEVyYU5hbWUiLCJnZXRFcmFOYXJyb3ciLCJnZXRFcmFBYmJyIiwiZ2V0RXJhWWVhciIsImVyYXNOYW1lUmVnZXgiLCJjb21wdXRlRXJhc1BhcnNlIiwiX2VyYXNOYW1lUmVnZXgiLCJfZXJhc1JlZ2V4IiwiZXJhc0FiYnJSZWdleCIsIl9lcmFzQWJiclJlZ2V4IiwiZXJhc05hcnJvd1JlZ2V4IiwiX2VyYXNOYXJyb3dSZWdleCIsImFiYnJQaWVjZXMiLCJuYW1lUGllY2VzIiwibmFycm93UGllY2VzIiwiaXNvV2Vla1llYXIiLCJhZGRXZWVrWWVhckZvcm1hdFRva2VuIiwiZ2V0dGVyIiwiZ2V0U2V0V2Vla1llYXIiLCJnZXRTZXRXZWVrWWVhckhlbHBlciIsImdldFNldElTT1dlZWtZZWFyIiwiZ2V0SVNPV2Vla3NJblllYXIiLCJnZXRJU09XZWVrc0luSVNPV2Vla1llYXIiLCJnZXRXZWVrc0luWWVhciIsIndlZWtJbmZvIiwiZ2V0V2Vla3NJbldlZWtZZWFyIiwid2Vla3NUYXJnZXQiLCJzZXRXZWVrQWxsIiwiZGF5T2ZZZWFyRGF0YSIsImdldFNldFF1YXJ0ZXIiLCJnZXRTZXREYXlPZk1vbnRoIiwiZ2V0U2V0RGF5T2ZZZWFyIiwiZ2V0U2V0TWludXRlIiwiZ2V0U2V0U2Vjb25kIiwiZ2V0U2V0TWlsbGlzZWNvbmQiLCJwYXJzZU1zIiwiZ2V0Wm9uZUFiYnIiLCJnZXRab25lTmFtZSIsInByb3RvIiwiU3ltYm9sIiwiZm9yIiwiZXJhTmFycm93IiwiZXJhQWJiciIsImVyYVllYXIiLCJpc29XZWVrcyIsIndlZWtzSW5XZWVrWWVhciIsImlzb1dlZWtzSW5ZZWFyIiwiaXNvV2Vla3NJbklTT1dlZWtZZWFyIiwicGFyc2Vab25lIiwiaXNEU1QiLCJ6b25lQWJiciIsInpvbmVOYW1lIiwiZGF0ZXMiLCJpc0RTVFNoaWZ0ZWQiLCJjcmVhdGVVbml4IiwiY3JlYXRlSW5ab25lIiwicHJlUGFyc2VQb3N0Rm9ybWF0IiwicHJvdG8kMSIsImZpcnN0RGF5T2ZZZWFyIiwiZmlyc3REYXlPZldlZWsiLCJnZXQkMSIsImluZGV4IiwiZmllbGQiLCJzZXR0ZXIiLCJsaXN0TW9udGhzSW1wbCIsIm91dCIsImxpc3RXZWVrZGF5c0ltcGwiLCJsb2NhbGVTb3J0ZWQiLCJzaGlmdCIsImxpc3RNb250aHMiLCJsaXN0TW9udGhzU2hvcnQiLCJsaXN0V2Vla2RheXMiLCJsaXN0V2Vla2RheXNTaG9ydCIsImxpc3RXZWVrZGF5c01pbiIsImxhbmdEYXRhIiwibWF0aEFicyIsImFkZFN1YnRyYWN0JDEiLCJhZGQkMSIsInN1YnRyYWN0JDEiLCJhYnNDZWlsIiwiYnViYmxlIiwibW9udGhzRnJvbURheXMiLCJtb250aHNUb0RheXMiLCJkYXlzVG9Nb250aHMiLCJhcyIsInZhbHVlT2YkMSIsIm1ha2VBcyIsImFsaWFzIiwiYXNNaWxsaXNlY29uZHMiLCJhc1NlY29uZHMiLCJhc01pbnV0ZXMiLCJhc0hvdXJzIiwiYXNEYXlzIiwiYXNXZWVrcyIsImFzTW9udGhzIiwiYXNRdWFydGVycyIsImFzWWVhcnMiLCJjbG9uZSQxIiwiZ2V0JDIiLCJtYWtlR2V0dGVyIiwidGhyZXNob2xkcyIsInN1YnN0aXR1dGVUaW1lQWdvIiwicmVsYXRpdmVUaW1lJDEiLCJwb3NOZWdEdXJhdGlvbiIsImdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nIiwicm91bmRpbmdGdW5jdGlvbiIsImdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCIsInRocmVzaG9sZCIsImxpbWl0IiwiYXJnV2l0aFN1ZmZpeCIsImFyZ1RocmVzaG9sZHMiLCJ3aXRoU3VmZml4IiwidGgiLCJhc3NpZ24iLCJhYnMkMSIsInRvSVNPU3RyaW5nJDEiLCJ0b3RhbCIsInRvdGFsU2lnbiIsInltU2lnbiIsImRheXNTaWduIiwiaG1zU2lnbiIsInRvRml4ZWQiLCJwcm90byQyIiwidG9Jc29TdHJpbmciLCJ2ZXJzaW9uIiwicmVsYXRpdmVUaW1lUm91bmRpbmciLCJyZWxhdGl2ZVRpbWVUaHJlc2hvbGQiLCJIVE1MNV9GTVQiLCJEQVRFVElNRV9MT0NBTCIsIkRBVEVUSU1FX0xPQ0FMX1NFQ09ORFMiLCJEQVRFVElNRV9MT0NBTF9NUyIsIlRJTUUiLCJUSU1FX1NFQ09ORFMiLCJUSU1FX01TIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/moment/moment.js\n");

/***/ })

};
;